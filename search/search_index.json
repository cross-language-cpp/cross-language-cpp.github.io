{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple IDL \u00b6 The Djinni Interface Definition Language provides a simple, yet powerful way to design your interfaces. IDE Integration \u00b6 Plugins for Djinni are available for IntelliJ IDEA & VS Code Blurs the Line Between Languages \u00b6 With Djinni you can implement interfaces in any target language and call the implementation from C++! Can Target any Operating System \u00b6 Djinni comes with support for native app development on every popular OS: Maintained by a Small, but Active Community \u00b6 Djinni was originally developed by Dropbox in 2014. Since June 2020 it is independently maintained by a small group of individuals from all over the globe. Get in contact with us on the Mobile C++ Slack !","title":"Home"},{"location":"#simple-idl","text":"The Djinni Interface Definition Language provides a simple, yet powerful way to design your interfaces.","title":"Simple IDL"},{"location":"#ide-integration","text":"Plugins for Djinni are available for IntelliJ IDEA & VS Code","title":"IDE Integration"},{"location":"#blurs-the-line-between-languages","text":"With Djinni you can implement interfaces in any target language and call the implementation from C++!","title":"Blurs the Line Between Languages"},{"location":"#can-target-any-operating-system","text":"Djinni comes with support for native app development on every popular OS:","title":"Can Target any Operating System"},{"location":"#maintained-by-a-small-but-active-community","text":"Djinni was originally developed by Dropbox in 2014. Since June 2020 it is independently maintained by a small group of individuals from all over the globe. Get in contact with us on the Mobile C++ Slack !","title":"Maintained by a Small, but Active Community"},{"location":"contributing/","text":"Contributing \u00b6 The cross-language-cpp project \u00b6 Cross-language-cpp is driven by individual people on a volunteer base. The idea for this project has been born at the Mobile C++ slack channel. Motivation \u00b6 Already before the sunset of the original djinni project it was not possible anymore to contribute to the project. A lot of ideas, bug fixes and new features have not been reported or submitted upstream. They are either available in various personal forks of djinni, or not available at all. Just to name an example, there are various javascript/nodejs implementation for djinni out there. They are all in personal forks, Often these project do not even know from each other. This is not optimal. Goals \u00b6 Continuation of the development of djinni and it's related tools. Avoid a single point of failure for the project. The goal is to have enough maintainers so the project will always have some administrator, and a read only state like the original project can be avoided. Be the place where new ideas and improvements to djinni and it's tools are collected and implemented. Becoming involved in the project \u00b6 As any open source project, we depend on the work of people that contribute to the project. Contributing to the project \u00b6 As mentioned, there have been various extension and additions to djinni been made. But most creators say the same: This is just a personal extension, a fast hack to make something work, not good enough for public release. These are all common reasons for not publishing code, and we think that they are not correct or should not be an impediment for not pushing changes back upstream. Release early, release often, if something is not good enough, it will either be not used or fixed. Open source evolution will care about. But the essential requirement is, make the changes available. There is nothing to lose, but everything to win! Becoming a maintainer \u00b6 As mentioned, one of the goals of the project is to establish a structure that ensures the availability of the project over time. For this to happen, maintainers are needed! For being a maintainer, we think the following points are important: Be available and responsive (as your time allows) : Respond in time to user request, or just be there when your time allows it. A reply I do not know now but I will come back is better than no reply for people that visit the project. Be reliable : If you admit to do something, please do not disappear without any notice. Be consistent (for some time) : It is common that people pop in full with ideas and energy, and this is great and such people are usual great contributors! But for a maintainer role it is also important to be consistent for more than just a few days or until 1 issue is realized or solved. No one expects commitment of a live time, but by taking a maintainer maybe for more than one week.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#the-cross-language-cpp-project","text":"Cross-language-cpp is driven by individual people on a volunteer base. The idea for this project has been born at the Mobile C++ slack channel.","title":"The cross-language-cpp project"},{"location":"contributing/#motivation","text":"Already before the sunset of the original djinni project it was not possible anymore to contribute to the project. A lot of ideas, bug fixes and new features have not been reported or submitted upstream. They are either available in various personal forks of djinni, or not available at all. Just to name an example, there are various javascript/nodejs implementation for djinni out there. They are all in personal forks, Often these project do not even know from each other. This is not optimal.","title":"Motivation"},{"location":"contributing/#goals","text":"Continuation of the development of djinni and it's related tools. Avoid a single point of failure for the project. The goal is to have enough maintainers so the project will always have some administrator, and a read only state like the original project can be avoided. Be the place where new ideas and improvements to djinni and it's tools are collected and implemented.","title":"Goals"},{"location":"contributing/#becoming-involved-in-the-project","text":"As any open source project, we depend on the work of people that contribute to the project.","title":"Becoming involved in the project"},{"location":"contributing/#contributing-to-the-project","text":"As mentioned, there have been various extension and additions to djinni been made. But most creators say the same: This is just a personal extension, a fast hack to make something work, not good enough for public release. These are all common reasons for not publishing code, and we think that they are not correct or should not be an impediment for not pushing changes back upstream. Release early, release often, if something is not good enough, it will either be not used or fixed. Open source evolution will care about. But the essential requirement is, make the changes available. There is nothing to lose, but everything to win!","title":"Contributing to the project"},{"location":"contributing/#becoming-a-maintainer","text":"As mentioned, one of the goals of the project is to establish a structure that ensures the availability of the project over time. For this to happen, maintainers are needed! For being a maintainer, we think the following points are important: Be available and responsive (as your time allows) : Respond in time to user request, or just be there when your time allows it. A reply I do not know now but I will come back is better than no reply for people that visit the project. Be reliable : If you admit to do something, please do not disappear without any notice. Be consistent (for some time) : It is common that people pop in full with ideas and energy, and this is great and such people are usual great contributors! But for a maintainer role it is also important to be consistent for more than just a few days or until 1 issue is realized or solved. No one expects commitment of a live time, but by taking a maintainer maybe for more than one week.","title":"Becoming a maintainer"},{"location":"example/","text":"Example \u00b6 iOS \u00b6 TODO Android \u00b6 TODO Windows \u00b6 TODO","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#ios","text":"TODO","title":"iOS"},{"location":"example/#android","text":"TODO","title":"Android"},{"location":"example/#windows","text":"TODO","title":"Windows"},{"location":"icon_resources/","text":"Djinni Logo Resources \u00b6 The cross-language-cpp Djinni has a new, unique logo. If you want to report about or reference to our project, please make sure to use the official logo resources: Icon (800x800) Full Logo (1189 x 500) Affinity Designer Resource file","title":"Djinni Logo Resources"},{"location":"icon_resources/#djinni-logo-resources","text":"The cross-language-cpp Djinni has a new, unique logo. If you want to report about or reference to our project, please make sure to use the official logo resources: Icon (800x800) Full Logo (1189 x 500) Affinity Designer Resource file","title":"Djinni Logo Resources"},{"location":"overview/","text":"Overview \u00b6 What is djinni? \u00b6 Djinni is a tool for generating cross-language type declarations and interface bindings to connect C++ with either Java, Objective-C, Python or C#. Djinni can be used to interface cross-platform C++ library code with platform-specific code on any popular operating system. Djinni was announced by Dropbox at CppCon 2014: Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. Since June 2020 this fork gives Djinni a second life by maintaining it as a community-driven project in the cross-language-cpp organization! How the magic works \u00b6 To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from an interface definition language (IDL) . All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and managing memory. Example: Call C++ Code from Java or Objective-C This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static create(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Example: Call Java/Objective-C Code from C++ This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ; Main Features \u00b6 Generates parallel C++, Java, Objective-C, Python and C++/CLI type definitions from a single interface description file. Supports the intersection of the languages' primitive types, and user-defined enums, flags, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and ... ... Java (with JNI) ... Objective-C (with Objective-C++) ... Python (with CFFI) ... C# (with C++/CLI) Can autogenerate comparator functions (equality, ordering) on data types. Components of Djinni \u00b6 Djinni consists of two core components: Generator : Command-line tool that takes an IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#what-is-djinni","text":"Djinni is a tool for generating cross-language type declarations and interface bindings to connect C++ with either Java, Objective-C, Python or C#. Djinni can be used to interface cross-platform C++ library code with platform-specific code on any popular operating system. Djinni was announced by Dropbox at CppCon 2014: Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. Since June 2020 this fork gives Djinni a second life by maintaining it as a community-driven project in the cross-language-cpp organization!","title":"What is djinni?"},{"location":"overview/#how-the-magic-works","text":"To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from an interface definition language (IDL) . All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and managing memory. Example: Call C++ Code from Java or Objective-C This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static create(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Example: Call Java/Objective-C Code from C++ This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ;","title":"How the magic works"},{"location":"overview/#main-features","text":"Generates parallel C++, Java, Objective-C, Python and C++/CLI type definitions from a single interface description file. Supports the intersection of the languages' primitive types, and user-defined enums, flags, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and ... ... Java (with JNI) ... Objective-C (with Objective-C++) ... Python (with CFFI) ... C# (with C++/CLI) Can autogenerate comparator functions (equality, ordering) on data types.","title":"Main Features"},{"location":"overview/#components-of-djinni","text":"Djinni consists of two core components: Generator : Command-line tool that takes an IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Components of Djinni"},{"location":"setup/","text":"Setup \u00b6 The following steps are required to get you started: 1. Installation of Generator \u00b6 Get the latest version of the generator from github . Go here for more detailed install instructions. 2. Add the support-lib to your project \u00b6 The support-lib will be available for multiple package managers soon. Stay tuned! Go here for more detailed install instructions. 3. Install IDE Plugin \u00b6 For syntax checking and highlighting of the Djinni-IDL install the plugin for your IDE: VS Code : ( download , documentation ) IntelliJ IDEA : ( download , documentation )","title":"Setup"},{"location":"setup/#setup","text":"The following steps are required to get you started:","title":"Setup"},{"location":"setup/#1-installation-of-generator","text":"Get the latest version of the generator from github . Go here for more detailed install instructions.","title":"1. Installation of Generator"},{"location":"setup/#2-add-the-support-lib-to-your-project","text":"The support-lib will be available for multiple package managers soon. Stay tuned! Go here for more detailed install instructions.","title":"2. Add the support-lib to your project"},{"location":"setup/#3-install-ide-plugin","text":"For syntax checking and highlighting of the Djinni-IDL install the plugin for your IDE: VS Code : ( download , documentation ) IntelliJ IDEA : ( download , documentation )","title":"3. Install IDE Plugin"},{"location":"djinni-generator/cli-usage/","text":"Using the Generator \u00b6 When the Djinni file(s) are ready, from the command line you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --py-out PYTHON_OUTPUT_FOLDER \\ --pycffi-out CFFI_OUTPUT_FOLDER \\ # Required for Python support --pycffi-package-name PyCFFIlib \\ --pycffi-dynamic-lib-list mylib \\ --c-wrapper-out C_WRAPPER_OUTPUT_FOLDER \\ # Required for Python support \\ --idl MY_PROJECT.djinni Note If a language's output folder is not specified, that language will not be generated. All Arguments \u00b6 General \u00b6 Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import and @extern directives. Can specify multiple paths. Java \u00b6 Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false ). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ). C++ \u00b6 Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false ) JNI \u00b6 Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base support library's include path (default: djinni/jni/ ). --jni-generate-main <true/false> Generate a source file ( djinni_jni_main.cpp ) that includes the default JNI_OnLoad & JNI_OnUnload implementation from the support library. (default: true ) Objective-C \u00b6 Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-header-out <out-folder> The output folder for Objective-C header files (default: the same as --objc-out ). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. The output folder is --objc-header-out . --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ). Objective-C++ \u00b6 Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C base support library's include path (default: djinni/objc/ ). Python \u00b6 Argument Description --py-out <out-folder> The output folder for Python files (Generator disabled if unspecified). --pycffi-out <out-folder> The output folder for PyCFFI files (Generator disabled if unspecified). --pycffi-package-name ... The package name to use for the generated PyCFFI classes. --pycffi-dynamic-lib-list ... The names of the dynamic libraries to be linked with PyCFFI. --c-wrapper-out <out-folder> The output folder for C wrapper files (Generator disabled if unspecified). --c-wrapper-header-out <out-folder> The output folder for C wrapper header files (default: the same as --c-wrapper-out ). --c-wrapper-include-prefix <prefix> The prefix for #includes of C wrapper header files from C wrapper C++ files. --c-wrapper-include-cpp-prefix <prefix> The prefix for #includes of C++ header files from C wrapper C++ files. --c-wrapper-base-lib-include-prefix <prefix> The C wrapper base support library's include path (default: djinni/cwrapper/ ). --py-import-prefix <import-prefix> The import prefix used within python generated files (default: \"\") C++/CLI \u00b6 Argument Description --cppcli-out <out-folder> The output folder for C++/CLI files (Generator disabled if unspecified). --cppcli-namespace ... The namespace name to use for generated C++/CLI classes. --cppcli-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from C++/CLI files. --cppcli-base-lib-include-prefix <prefix> The C++/CLI base support library's include path (default: djinni/cppcli/ ). Yaml Generation \u00b6 Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\"). Other \u00b6 Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false ) Identifier Style \u00b6 The Identifier Style is a text conversion hint on how to generate names from the djinni idl file. Possible values: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar . C++ \u00b6 Argument Default --ident-cpp-enum FOO_BAR --ident-cpp-field foo_bar --ident-cpp-method foo_bar --ident-cpp-type FooBar --ident-cpp-enum-type FooBar --ident-cpp-type-param FooBar --ident-cpp-local foo_bar --ident-cpp-file foo_bar Java \u00b6 Argument Default --ident-java-enum FOO_BAR --ident-java-field fooBar --ident-java-type FooBar --ident-jni-class FooBar --ident-jni-file foo_bar Objective C \u00b6 Argument Default --ident-objc-enum FooBar --ident-objc-field fooBar --ident-objc-method fooBar --ident-objc-type FooBar --ident-objc-type-param FooBar --ident-objc-local fooBar --ident-objc-file FooBar Python \u00b6 Argument Default --ident-py-type foo_bar --ident-py-class-name FooBar --ident-py-type-param foo_bar --ident-py-method foo_bar --ident-py-field foo_bar --ident-py-local foo_bar --ident-py-enum Foo_Bar --ident-py-const FOO_BAR C++/CLI \u00b6 Argument Default --ident-cppcli-type FooBar --ident-cppcli-type-param FooBar --ident-cppcli-property FooBar --ident-cppcli-method FooBar --ident-cppcli-local fooBar --ident-cppcli-enum FooBar --ident-cppcli-const FooBar --ident-cppcli-file FooBar Example: The djinni idl for an enum SomeEnum = enum { Value; } transforms per default to the following Java code public enum SomeEnum { VALUE, ; } As you see, VALUE is now in upper case letters. If you use --ident-java-enum foo_bar then Value will not be transformed into upper case and the following Java code will be generated. public enum SomeEnum { Value, ; } This way you can adopt code generation to some extend to your existing coding style. The best way to find out how that works is playing around with different values for different identifier options. If you wish no text transformation to happen, use the foo_bar style. Note Some identifiers do have text transformation enabled by default. Nevertheless make sure to explicitly set text transformation styles if you need them! All text transformation may be disabled by default in a future release of the generator.","title":"Using the Generator"},{"location":"djinni-generator/cli-usage/#using-the-generator","text":"When the Djinni file(s) are ready, from the command line you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --py-out PYTHON_OUTPUT_FOLDER \\ --pycffi-out CFFI_OUTPUT_FOLDER \\ # Required for Python support --pycffi-package-name PyCFFIlib \\ --pycffi-dynamic-lib-list mylib \\ --c-wrapper-out C_WRAPPER_OUTPUT_FOLDER \\ # Required for Python support \\ --idl MY_PROJECT.djinni Note If a language's output folder is not specified, that language will not be generated.","title":"Using the Generator"},{"location":"djinni-generator/cli-usage/#all-arguments","text":"","title":"All Arguments"},{"location":"djinni-generator/cli-usage/#general","text":"Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import and @extern directives. Can specify multiple paths.","title":"General"},{"location":"djinni-generator/cli-usage/#java","text":"Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false ). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ).","title":"Java"},{"location":"djinni-generator/cli-usage/#c","text":"Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false )","title":"C++"},{"location":"djinni-generator/cli-usage/#jni","text":"Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base support library's include path (default: djinni/jni/ ). --jni-generate-main <true/false> Generate a source file ( djinni_jni_main.cpp ) that includes the default JNI_OnLoad & JNI_OnUnload implementation from the support library. (default: true )","title":"JNI"},{"location":"djinni-generator/cli-usage/#objective-c","text":"Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-header-out <out-folder> The output folder for Objective-C header files (default: the same as --objc-out ). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. The output folder is --objc-header-out . --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ).","title":"Objective-C"},{"location":"djinni-generator/cli-usage/#objective-c_1","text":"Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C base support library's include path (default: djinni/objc/ ).","title":"Objective-C++"},{"location":"djinni-generator/cli-usage/#python","text":"Argument Description --py-out <out-folder> The output folder for Python files (Generator disabled if unspecified). --pycffi-out <out-folder> The output folder for PyCFFI files (Generator disabled if unspecified). --pycffi-package-name ... The package name to use for the generated PyCFFI classes. --pycffi-dynamic-lib-list ... The names of the dynamic libraries to be linked with PyCFFI. --c-wrapper-out <out-folder> The output folder for C wrapper files (Generator disabled if unspecified). --c-wrapper-header-out <out-folder> The output folder for C wrapper header files (default: the same as --c-wrapper-out ). --c-wrapper-include-prefix <prefix> The prefix for #includes of C wrapper header files from C wrapper C++ files. --c-wrapper-include-cpp-prefix <prefix> The prefix for #includes of C++ header files from C wrapper C++ files. --c-wrapper-base-lib-include-prefix <prefix> The C wrapper base support library's include path (default: djinni/cwrapper/ ). --py-import-prefix <import-prefix> The import prefix used within python generated files (default: \"\")","title":"Python"},{"location":"djinni-generator/cli-usage/#ccli","text":"Argument Description --cppcli-out <out-folder> The output folder for C++/CLI files (Generator disabled if unspecified). --cppcli-namespace ... The namespace name to use for generated C++/CLI classes. --cppcli-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from C++/CLI files. --cppcli-base-lib-include-prefix <prefix> The C++/CLI base support library's include path (default: djinni/cppcli/ ).","title":"C++/CLI"},{"location":"djinni-generator/cli-usage/#yaml-generation","text":"Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\").","title":"Yaml Generation"},{"location":"djinni-generator/cli-usage/#other","text":"Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false )","title":"Other"},{"location":"djinni-generator/cli-usage/#identifier-style","text":"The Identifier Style is a text conversion hint on how to generate names from the djinni idl file. Possible values: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar .","title":"Identifier Style"},{"location":"djinni-generator/cli-usage/#c_1","text":"Argument Default --ident-cpp-enum FOO_BAR --ident-cpp-field foo_bar --ident-cpp-method foo_bar --ident-cpp-type FooBar --ident-cpp-enum-type FooBar --ident-cpp-type-param FooBar --ident-cpp-local foo_bar --ident-cpp-file foo_bar","title":"C++"},{"location":"djinni-generator/cli-usage/#java_1","text":"Argument Default --ident-java-enum FOO_BAR --ident-java-field fooBar --ident-java-type FooBar --ident-jni-class FooBar --ident-jni-file foo_bar","title":"Java"},{"location":"djinni-generator/cli-usage/#objective-c_2","text":"Argument Default --ident-objc-enum FooBar --ident-objc-field fooBar --ident-objc-method fooBar --ident-objc-type FooBar --ident-objc-type-param FooBar --ident-objc-local fooBar --ident-objc-file FooBar","title":"Objective C"},{"location":"djinni-generator/cli-usage/#python_1","text":"Argument Default --ident-py-type foo_bar --ident-py-class-name FooBar --ident-py-type-param foo_bar --ident-py-method foo_bar --ident-py-field foo_bar --ident-py-local foo_bar --ident-py-enum Foo_Bar --ident-py-const FOO_BAR","title":"Python"},{"location":"djinni-generator/cli-usage/#ccli_1","text":"Argument Default --ident-cppcli-type FooBar --ident-cppcli-type-param FooBar --ident-cppcli-property FooBar --ident-cppcli-method FooBar --ident-cppcli-local fooBar --ident-cppcli-enum FooBar --ident-cppcli-const FooBar --ident-cppcli-file FooBar Example: The djinni idl for an enum SomeEnum = enum { Value; } transforms per default to the following Java code public enum SomeEnum { VALUE, ; } As you see, VALUE is now in upper case letters. If you use --ident-java-enum foo_bar then Value will not be transformed into upper case and the following Java code will be generated. public enum SomeEnum { Value, ; } This way you can adopt code generation to some extend to your existing coding style. The best way to find out how that works is playing around with different values for different identifier options. If you wish no text transformation to happen, use the foo_bar style. Note Some identifiers do have text transformation enabled by default. Nevertheless make sure to explicitly set text transformation styles if you need them! All text transformation may be disabled by default in a future release of the generator.","title":"C++/CLI"},{"location":"djinni-generator/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only interesting if you intend to make changes to the code of djinni generator Building from source \u00b6 Build dependencies \u00b6 Java JDK 8 or 11 sbt Building \u00b6 To build once: sbt compile To automatically re-build on every change, open the sbt shell & prefix compile with ~ $ sbt sbt:djinni> ~compile Running \u00b6 sbt \"run --idl input.djinni --cpp-out out/cpp --java-out out/java/src --jni-out out/java/jni --objc-out out/objc --py-out out/python --pycffi-out out/cffi --c-wrapper-out out/cwrapper --cppcli-out out/cppcli\" sbt \"run --help\" # show all options It is important to put run and all arguments in \" , to be able to pass arguments to the executed jar! Running Tests \u00b6 sbt it:test Packaging \u00b6 Create a binary like the one that is published on github releases: sbt assembly This will generate a standalone, self-executing jar in target/bin . You can run the jar like this: ./djinni --help On Windows the file must be renamed to djinni.bat to make it executable. Attention The resulting binary still requires Java to be able to run! Details on how the self-executing jar works . Project Structure \u00b6 . \u251c\u2500\u2500 CODE_OF_CONDUCT.md (1) \u251c\u2500\u2500 LICENSE (2) \u251c\u2500\u2500 README.md (3) \u251c\u2500\u2500 build.sbt (4) \u251c\u2500\u2500 docs (5) \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 mkdocs.yml (6) \u251c\u2500\u2500 project (7) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 src (8) \u251c\u2500\u2500 it (9) \u2502 \u251c\u2500\u2500 resources (10) \u2502 \u2502 \u251c\u2500\u2500 expected (11) \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u2514\u2500\u2500 result (12) \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 scala \u2502 \u2514\u2500\u2500 djinni (13) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 main \u2514\u2500\u2500 scala \u2514\u2500\u2500 djinni (14) \u2514\u2500\u2500 ... Project Code of Conduct. Project License (Apache License). Readme file. Sbt build configuration. Documentation folder containing markdown documentation that will be rendered with MkDocs. MkDocs configuration. Will be included by the cross-language-cpp.github.io repository and published to djinni.xlcpp.dev . Sbt configuration. Sources folder. Integration testing directory. Resources for integration tests. Folder containing expected outcomes of the djinni generator. These files are matched against the real result of the generator in the integration tests. Folder that will be used for generator outputs in the integration tests. Files in here should not be checked in to source control. Folder containing the integration testing code. djinni-generator source code. Preview Documentation \u00b6 The documentation in docs will be rendered as a part of djinni.xlcpp.dev . You can preview how the docs will look like: # install required dependencies pip install -r mkdocs-requirements.txt # render a live preview of the docs under http://127.0.0.1:8000 mkdocs serve Release process \u00b6 To release a new version of the generator, the following steps must be followed: Create a new release on Github. Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. The Github \"release\" Action will automatically build the project and upload the resulting binaries to the release. Create a PR to the conan-center-index to publish the new version to Conan Center .","title":"Developer Guide"},{"location":"djinni-generator/developer-guide/#developer-guide","text":"Info This chapter is only interesting if you intend to make changes to the code of djinni generator","title":"Developer Guide"},{"location":"djinni-generator/developer-guide/#building-from-source","text":"","title":"Building from source"},{"location":"djinni-generator/developer-guide/#build-dependencies","text":"Java JDK 8 or 11 sbt","title":"Build dependencies"},{"location":"djinni-generator/developer-guide/#building","text":"To build once: sbt compile To automatically re-build on every change, open the sbt shell & prefix compile with ~ $ sbt sbt:djinni> ~compile","title":"Building"},{"location":"djinni-generator/developer-guide/#running","text":"sbt \"run --idl input.djinni --cpp-out out/cpp --java-out out/java/src --jni-out out/java/jni --objc-out out/objc --py-out out/python --pycffi-out out/cffi --c-wrapper-out out/cwrapper --cppcli-out out/cppcli\" sbt \"run --help\" # show all options It is important to put run and all arguments in \" , to be able to pass arguments to the executed jar!","title":"Running"},{"location":"djinni-generator/developer-guide/#running-tests","text":"sbt it:test","title":"Running Tests"},{"location":"djinni-generator/developer-guide/#packaging","text":"Create a binary like the one that is published on github releases: sbt assembly This will generate a standalone, self-executing jar in target/bin . You can run the jar like this: ./djinni --help On Windows the file must be renamed to djinni.bat to make it executable. Attention The resulting binary still requires Java to be able to run! Details on how the self-executing jar works .","title":"Packaging"},{"location":"djinni-generator/developer-guide/#project-structure","text":". \u251c\u2500\u2500 CODE_OF_CONDUCT.md (1) \u251c\u2500\u2500 LICENSE (2) \u251c\u2500\u2500 README.md (3) \u251c\u2500\u2500 build.sbt (4) \u251c\u2500\u2500 docs (5) \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 mkdocs.yml (6) \u251c\u2500\u2500 project (7) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 src (8) \u251c\u2500\u2500 it (9) \u2502 \u251c\u2500\u2500 resources (10) \u2502 \u2502 \u251c\u2500\u2500 expected (11) \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u2514\u2500\u2500 result (12) \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 scala \u2502 \u2514\u2500\u2500 djinni (13) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 main \u2514\u2500\u2500 scala \u2514\u2500\u2500 djinni (14) \u2514\u2500\u2500 ... Project Code of Conduct. Project License (Apache License). Readme file. Sbt build configuration. Documentation folder containing markdown documentation that will be rendered with MkDocs. MkDocs configuration. Will be included by the cross-language-cpp.github.io repository and published to djinni.xlcpp.dev . Sbt configuration. Sources folder. Integration testing directory. Resources for integration tests. Folder containing expected outcomes of the djinni generator. These files are matched against the real result of the generator in the integration tests. Folder that will be used for generator outputs in the integration tests. Files in here should not be checked in to source control. Folder containing the integration testing code. djinni-generator source code.","title":"Project Structure"},{"location":"djinni-generator/developer-guide/#preview-documentation","text":"The documentation in docs will be rendered as a part of djinni.xlcpp.dev . You can preview how the docs will look like: # install required dependencies pip install -r mkdocs-requirements.txt # render a live preview of the docs under http://127.0.0.1:8000 mkdocs serve","title":"Preview Documentation"},{"location":"djinni-generator/developer-guide/#release-process","text":"To release a new version of the generator, the following steps must be followed: Create a new release on Github. Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. The Github \"release\" Action will automatically build the project and upload the resulting binaries to the release. Create a PR to the conan-center-index to publish the new version to Conan Center .","title":"Release process"},{"location":"djinni-generator/generated-code-usage/","text":"Use Generated Code \u00b6 Java / JNI / C++ Project \u00b6 Includes & Build target \u00b6 The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Additionally djinni_jni_main.cpp is generated to provide a default implementation for JNI_OnLoad and JNI_OnUnload , if --jni-generate-main=true . Add all generated source files to your build target, and link the C++ code against the djinni-support-lib . Our JNI approach \u00b6 JNI stands for Java Native Interface , an extension of the Java language to allow interop with native (C/C++) code or libraries. For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: class Main { static { System . loadLibrary ( \"YourLibraryName\" ); // The name of the library is specified in Android.mk / build.gradle / Makefile / CMakeLists.txt, // depending on your build system. } } If you package your native library in a jar, you can also use the NativeLibLoader to help unpack and load your lib(s). Any library loaded from Java should provide the functions JNI_OnLoad and JNI_OnUnload . They are called by JNI when the library is loaded/unloaded. Djinni uses these functions to initialize & cleanup internal structures. The generated file djinni_jni_main.cpp includes a default implementation of JNI_Onload and JNI_OnUnload functions provided by the support library. If you are building a library that does not use JNI except through Djinni, this default should work well for you. If want to provide your own implementation of JNI_Onload and JNI_OnUnload , the generation of djinni_jni_main.cpp can be disabled by setting --jni-generate-main=false . Objective-C / C++ Project \u00b6 Includes & Build Target \u00b6 Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm Generated only for types that contain constants. Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, and link against the djinni-support-lib . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface. Python / C++ Project (Experimental) \u00b6 Python support in Djinni is experimental, but ready to try out. It can generate code for bridging C++ with Python 3. For more information, you can check out the talk from CppCon 2015. Slides and video are available online. Includes & Build Target \u00b6 When bridging to Python, Djinni generates 4 types of output: python Generated Python classes and proxies for interacting with C++ via CFFI . cffi Python code run at build time to create a Python extension out of the C++ code. cwrapper A C interface implemented in C++ to allowing Python to interact with C++ classes. cpp The same C++ classes generated for all other Djinni languages. Generated files for Python / C++ are as follows: Type C++ header C++ source Python files CFFI C Wrapper Enum/Flags my_enum.hpp my_enum.py dh__my_enum.cpp dh__my_enum.h dh__my_enum.hpp Record my_record[_base].hpp my_record[_base].cpp my_record[_base].py dh__my_record.cpp dh__my_record.h dh__my_record.hpp Interface my_interface.hpp my_interface.cpp my_interface.py pycffi_lib_build.py cw__my_interface.cpp cw__my_interface.h cw__my_interface.hpp Generated only for types that contain constants. Additional C Wrapper files are generated for data structures; their names are encoded as: dh__{list,set,map}_{encoded_type(s)}.cpp dh__{list,set,map}_{encoded_type(s)}.h dh__{list,set,map}_{encoded_type(s)}.hpp See the in the table below a few examples: Type C Wrapper list<i32> dh__list_int32_t.{cpp,h,hpp} set<string> dh__set_string.{cpp,h,hpp} map<i32, set<string>> dh__map_int32_t_set_string.{cpp,h,hpp} Add all generated C and C++ source files to your build target, and link it against the djinni-support-lib . Compile the Python extension module (CFFI) by executing pycffi_lib_build.py while providing all C Wrapper header files ( .h ) as arguments. The resulting shared library will enable Python to access your C++ library through the CFFI bridge. Known limitations of the generator \u00b6 External types defined in YAML are not yet supported. Use of non-nullable pointers is not yet supported. C++/CLI / C++ Project \u00b6 C++/CLI is a technology by Microsoft that provides interoperability of C++ with Microsoft .NET languages such as C#. It is only supported on Windows. Djinni generates a shallow C++/CLI wrapper around the C++ interfaces. Once compiled to a shared library, the resulting dll just needs to be added to your C# project as reference, and you can call your Djinni interfaces from C# like any other .NET library. Includes & Build target \u00b6 The following code will be generated for each defined type: Type C++ header C++ source C++/CLI header/sources Enum/Flags my_enum.hpp MyEnum.hpp, MyEnum.cpp Record my_record.hpp my_record.cpp MyRecord.hpp, MyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.hpp, MyInterface.cpp Add all generated files to your build target, and link against the djinni-support-lib . C++/CLI sources have to be compiled with MSVC and the /clr (Common Language Runtime Compilation) option.","title":"Use Generated Code"},{"location":"djinni-generator/generated-code-usage/#use-generated-code","text":"","title":"Use Generated Code"},{"location":"djinni-generator/generated-code-usage/#java-jni-c-project","text":"","title":"Java / JNI / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target","text":"The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Additionally djinni_jni_main.cpp is generated to provide a default implementation for JNI_OnLoad and JNI_OnUnload , if --jni-generate-main=true . Add all generated source files to your build target, and link the C++ code against the djinni-support-lib .","title":"Includes &amp; Build target"},{"location":"djinni-generator/generated-code-usage/#our-jni-approach","text":"JNI stands for Java Native Interface , an extension of the Java language to allow interop with native (C/C++) code or libraries. For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: class Main { static { System . loadLibrary ( \"YourLibraryName\" ); // The name of the library is specified in Android.mk / build.gradle / Makefile / CMakeLists.txt, // depending on your build system. } } If you package your native library in a jar, you can also use the NativeLibLoader to help unpack and load your lib(s). Any library loaded from Java should provide the functions JNI_OnLoad and JNI_OnUnload . They are called by JNI when the library is loaded/unloaded. Djinni uses these functions to initialize & cleanup internal structures. The generated file djinni_jni_main.cpp includes a default implementation of JNI_Onload and JNI_OnUnload functions provided by the support library. If you are building a library that does not use JNI except through Djinni, this default should work well for you. If want to provide your own implementation of JNI_Onload and JNI_OnUnload , the generation of djinni_jni_main.cpp can be disabled by setting --jni-generate-main=false .","title":"Our JNI approach"},{"location":"djinni-generator/generated-code-usage/#objective-c-c-project","text":"","title":"Objective-C / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target_1","text":"Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm Generated only for types that contain constants. Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, and link against the djinni-support-lib . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface.","title":"Includes &amp; Build Target"},{"location":"djinni-generator/generated-code-usage/#python-c-project-experimental","text":"Python support in Djinni is experimental, but ready to try out. It can generate code for bridging C++ with Python 3. For more information, you can check out the talk from CppCon 2015. Slides and video are available online.","title":"Python / C++ Project (Experimental)"},{"location":"djinni-generator/generated-code-usage/#includes-build-target_2","text":"When bridging to Python, Djinni generates 4 types of output: python Generated Python classes and proxies for interacting with C++ via CFFI . cffi Python code run at build time to create a Python extension out of the C++ code. cwrapper A C interface implemented in C++ to allowing Python to interact with C++ classes. cpp The same C++ classes generated for all other Djinni languages. Generated files for Python / C++ are as follows: Type C++ header C++ source Python files CFFI C Wrapper Enum/Flags my_enum.hpp my_enum.py dh__my_enum.cpp dh__my_enum.h dh__my_enum.hpp Record my_record[_base].hpp my_record[_base].cpp my_record[_base].py dh__my_record.cpp dh__my_record.h dh__my_record.hpp Interface my_interface.hpp my_interface.cpp my_interface.py pycffi_lib_build.py cw__my_interface.cpp cw__my_interface.h cw__my_interface.hpp Generated only for types that contain constants. Additional C Wrapper files are generated for data structures; their names are encoded as: dh__{list,set,map}_{encoded_type(s)}.cpp dh__{list,set,map}_{encoded_type(s)}.h dh__{list,set,map}_{encoded_type(s)}.hpp See the in the table below a few examples: Type C Wrapper list<i32> dh__list_int32_t.{cpp,h,hpp} set<string> dh__set_string.{cpp,h,hpp} map<i32, set<string>> dh__map_int32_t_set_string.{cpp,h,hpp} Add all generated C and C++ source files to your build target, and link it against the djinni-support-lib . Compile the Python extension module (CFFI) by executing pycffi_lib_build.py while providing all C Wrapper header files ( .h ) as arguments. The resulting shared library will enable Python to access your C++ library through the CFFI bridge.","title":"Includes &amp; Build Target"},{"location":"djinni-generator/generated-code-usage/#known-limitations-of-the-generator","text":"External types defined in YAML are not yet supported. Use of non-nullable pointers is not yet supported.","title":"Known limitations of the generator"},{"location":"djinni-generator/generated-code-usage/#ccli-c-project","text":"C++/CLI is a technology by Microsoft that provides interoperability of C++ with Microsoft .NET languages such as C#. It is only supported on Windows. Djinni generates a shallow C++/CLI wrapper around the C++ interfaces. Once compiled to a shared library, the resulting dll just needs to be added to your C# project as reference, and you can call your Djinni interfaces from C# like any other .NET library.","title":"C++/CLI / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target_3","text":"The following code will be generated for each defined type: Type C++ header C++ source C++/CLI header/sources Enum/Flags my_enum.hpp MyEnum.hpp, MyEnum.cpp Record my_record.hpp my_record.cpp MyRecord.hpp, MyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.hpp, MyInterface.cpp Add all generated files to your build target, and link against the djinni-support-lib . C++/CLI sources have to be compiled with MSVC and the /clr (Common Language Runtime Compilation) option.","title":"Includes &amp; Build target"},{"location":"djinni-generator/idl/","text":"Interface Definition Language (IDL) \u00b6 Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC, Python and C# and can be called from C++. my_client_interface = interface +j +o +p +s { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once. Data Types \u00b6 The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, NSData in Objective-C, an object supporting the buffer interface in Python, and System.Array<System.Byte> in C#. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, NSDate in Objective-C, datetime.datetime in Python, and System.DateTime in C#. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, NSArray in Objective-C, List in Python, and System.Collections.Generic.List in C#. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, NSSet in Objective-C, Set in Python, and System.Collections.Generic.HashSet in C#. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, NSDictionary in Objective-C, Dictionary in Python, and System.Collections.Generic.Dictionary in C#. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents. Types \u00b6 An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, ObjC NS_ENUM s, Python IntEnum s, or C# System.Enum s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , ObjC NS_OPTIONS , Python IntFlag s, or C# System.Enum s with the [Flags] Attribute . Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java, Python or C#, and vice versa. Enums \u00b6 my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , Java enums, Python IntEnum s, and C# System.Enum s. Flags \u00b6 my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , Java EnumSet<> , Python IntFlag , and C# System.Enum s with the [Flags] Attribute . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++, ObjC, and Python the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() . Records \u00b6 my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself). Extensions \u00b6 To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), +o (ObjC), +p (Python), or +s (C#) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type. Derived methods \u00b6 another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java, Objective-C, Python and C#. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record. Interfaces \u00b6 # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC, Python and C# and can be called from C++. my_client_interface = interface +j +o +p +s { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java Python or C# and vice versa. Special Methods for C++ Only \u00b6 +c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor. Exception Handling \u00b6 When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java, an NSException in Objective-C, a RuntimeError in Python, or a System.Exception in C#. The what() message will be translated as well. Constants \u00b6 Constants can be defined within interfaces and records. In Java, Python, C# and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o +p +s { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, RecordWithConst.CONST_VALUE in Python, RecordWithConst.ConstValue in C#, and RecordWithConstConstValue in Objective-C. Comments \u00b6 # This is a comment If comments are placed on top or inside a type definition , they will be converted to Javadoc / Doxygen compatible comments in the generated Java/C++/Objective-C interfaces, or a Python docstring . Comments are currently not available in C#.","title":"Interface Definition Language (IDL)"},{"location":"djinni-generator/idl/#interface-definition-language-idl","text":"Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC, Python and C# and can be called from C++. my_client_interface = interface +j +o +p +s { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once.","title":"Interface Definition Language (IDL)"},{"location":"djinni-generator/idl/#data-types","text":"The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, NSData in Objective-C, an object supporting the buffer interface in Python, and System.Array<System.Byte> in C#. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, NSDate in Objective-C, datetime.datetime in Python, and System.DateTime in C#. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, NSArray in Objective-C, List in Python, and System.Collections.Generic.List in C#. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, NSSet in Objective-C, Set in Python, and System.Collections.Generic.HashSet in C#. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, NSDictionary in Objective-C, Dictionary in Python, and System.Collections.Generic.Dictionary in C#. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents.","title":"Data Types"},{"location":"djinni-generator/idl/#types","text":"An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, ObjC NS_ENUM s, Python IntEnum s, or C# System.Enum s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , ObjC NS_OPTIONS , Python IntFlag s, or C# System.Enum s with the [Flags] Attribute . Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java, Python or C#, and vice versa.","title":"Types"},{"location":"djinni-generator/idl/#enums","text":"my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , Java enums, Python IntEnum s, and C# System.Enum s.","title":"Enums"},{"location":"djinni-generator/idl/#flags","text":"my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , Java EnumSet<> , Python IntFlag , and C# System.Enum s with the [Flags] Attribute . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++, ObjC, and Python the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() .","title":"Flags"},{"location":"djinni-generator/idl/#records","text":"my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself).","title":"Records"},{"location":"djinni-generator/idl/#extensions","text":"To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), +o (ObjC), +p (Python), or +s (C#) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type.","title":"Extensions"},{"location":"djinni-generator/idl/#derived-methods","text":"another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java, Objective-C, Python and C#. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record.","title":"Derived methods"},{"location":"djinni-generator/idl/#interfaces","text":"# This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC, Python and C# and can be called from C++. my_client_interface = interface +j +o +p +s { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java Python or C# and vice versa.","title":"Interfaces"},{"location":"djinni-generator/idl/#special-methods-for-c-only","text":"+c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor.","title":"Special Methods for C++ Only"},{"location":"djinni-generator/idl/#exception-handling","text":"When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java, an NSException in Objective-C, a RuntimeError in Python, or a System.Exception in C#. The what() message will be translated as well.","title":"Exception Handling"},{"location":"djinni-generator/idl/#constants","text":"Constants can be defined within interfaces and records. In Java, Python, C# and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o +p +s { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, RecordWithConst.CONST_VALUE in Python, RecordWithConst.ConstValue in C#, and RecordWithConstConstValue in Objective-C.","title":"Constants"},{"location":"djinni-generator/idl/#comments","text":"# This is a comment If comments are placed on top or inside a type definition , they will be converted to Javadoc / Doxygen compatible comments in the generated Java/C++/Objective-C interfaces, or a Python docstring . Comments are currently not available in C#.","title":"Comments"},{"location":"djinni-generator/modularization/","text":"Modularization and Library Support \u00b6 When generating the interface for your project and wish to make it available to other users in all of C++/Objective-C/Java/C# you can tell Djinni to generate a special YAML file as part of the code generation process. This file then contains all the information Djinni requires to include your types in a different project. Instructing Djinni to create these YAML files is controlled by the YAML generation parameters . Caution External types defined in YAML are not yet supported for Python. YAML file structure \u00b6 Such a YAML file looks as follows: --- name : mylib_record1 typedef : 'record +c deriving(eq, ord)' params : [] prefix : 'mylib' cpp : typename : '::mylib::Record1' header : '\"MyLib/Record1.hpp\"' byValue : false objc : typename : 'MLBRecord1' header : '\"MLB/MLBRecord1.h\"' boxed : 'MLBRecord1' pointer : true hash : '%s.hash' objcpp : translator : '::mylib::djinni::objc::Record1' header : '\"mylib/djinni/objc/Record1.hpp\"' java : typename : 'com.example.mylib.Record1' boxed : 'com.example.mylib.Record1' reference : true generic : true hash : '%s.hashCode()' jni : translator : '::mylib::djinni::jni::Record1' header : '\"Duration-jni.hpp\"' typename : jobject typeSignature : 'Lcom/example/mylib/Record1;' cs : translator : '::djinni::Record1_h' header : '\"Record1-cs.hpp\"' typename : 'Record1^' reference : false --- name : mylib_interface1 typedef : 'interface +j +o +s' (...) --- name : mylib_enum1 typedef : 'enum' (...) Each document in the YAML file describes one extern type. You can also check these files for some real working examples of what you can do with it: date.yaml duration.yaml Usage \u00b6 To use a library type in your project simply include it in your IDL file and refer to it using its name identifier: @extern \"mylib.yaml\" client_interface = interface +c { foo(): mylib_record1; } Defining custom types \u00b6 The YAML files can be created by hand as long as you follow the required format. This allows you to support types not generated by Djinni. See duration.yaml and the accompanying translators in Duration-objc.hpp , Duration-jni.hpp and Duration-cs.hpp for an advanced example. Handwritten translators implement the following concept: // For C++ <-> Objective-C struct Record1 { using CppType = :: mylib :: Record1 ; using ObjcType = MLBRecord1 * ; static CppType toCpp ( ObjcType o ) { return /* your magic here */ ; } static ObjcType fromCpp ( CppType c ) { return /* your magic here */ ; } // Option 1: use this if no boxing is required using Boxed = Record1 ; // Option 2: or this if you do need dedicated boxing behavior struct Boxed { using ObjcType = MLBRecord1Special * ; static CppType toCpp ( ObjcType o ) { return /* your magic here */ ; } static ObjcType fromCpp ( CppType c ) { return /* your magic here */ ; } } }; // For C++ <-> JNI #include \"djinni_support.hpp\" struct Record1 { using CppType = :: mylib :: Record1 ; using JniType = jobject ; static CppType toCpp ( JniType j ) { return /* your magic here */ ; } // The return type *must* be LocalRef<T> if T is not a primitive! static :: djinni :: LocalRef < jobject > JniType fromCpp ( CppType c ) { return /* your magic here */ ; } using Boxed = Record1 ; }; // For C++ <-> C++/CLI public ref class Record1 { public : // Record1 public properties internal : using CppType = :: mylib :: Record1 ; using CsType = Record1 ^ ; static CppType ToCpp ( CsType cs ) { return /* your magic here */ ; } static CsType FromCpp ( const CppType & cs ) { return /* your magic here */ ; } private : // Record1 properties' backing fields } For interface classes the CppType alias is expected to be a std::shared_ptr<T> . Be sure to put the translators into representative and distinct namespaces. If your type is generic the translator takes the same number of template parameters. At usage each is instantiated with the translators of the respective type argument. template < class A , class B > struct Record1 { using CppType = :: mylib :: Record1 < typename A :: CppType , typename B :: CppType > ; using ObjcType = MLBRecord1 * ; static CppType toCpp ( ObjcType o ) { // Use A::toCpp() and B::toCpp() if necessary return /* your magic here */ ; } static ObjcType fromCpp ( CppType c ) { // Use A::fromCpp() and B::fromCpp() if necessary return /* your magic here */ ; } using Boxed = Record1 ; };","title":"Modularization and Library Support"},{"location":"djinni-generator/modularization/#modularization-and-library-support","text":"When generating the interface for your project and wish to make it available to other users in all of C++/Objective-C/Java/C# you can tell Djinni to generate a special YAML file as part of the code generation process. This file then contains all the information Djinni requires to include your types in a different project. Instructing Djinni to create these YAML files is controlled by the YAML generation parameters . Caution External types defined in YAML are not yet supported for Python.","title":"Modularization and Library Support"},{"location":"djinni-generator/modularization/#yaml-file-structure","text":"Such a YAML file looks as follows: --- name : mylib_record1 typedef : 'record +c deriving(eq, ord)' params : [] prefix : 'mylib' cpp : typename : '::mylib::Record1' header : '\"MyLib/Record1.hpp\"' byValue : false objc : typename : 'MLBRecord1' header : '\"MLB/MLBRecord1.h\"' boxed : 'MLBRecord1' pointer : true hash : '%s.hash' objcpp : translator : '::mylib::djinni::objc::Record1' header : '\"mylib/djinni/objc/Record1.hpp\"' java : typename : 'com.example.mylib.Record1' boxed : 'com.example.mylib.Record1' reference : true generic : true hash : '%s.hashCode()' jni : translator : '::mylib::djinni::jni::Record1' header : '\"Duration-jni.hpp\"' typename : jobject typeSignature : 'Lcom/example/mylib/Record1;' cs : translator : '::djinni::Record1_h' header : '\"Record1-cs.hpp\"' typename : 'Record1^' reference : false --- name : mylib_interface1 typedef : 'interface +j +o +s' (...) --- name : mylib_enum1 typedef : 'enum' (...) Each document in the YAML file describes one extern type. You can also check these files for some real working examples of what you can do with it: date.yaml duration.yaml","title":"YAML file structure"},{"location":"djinni-generator/modularization/#usage","text":"To use a library type in your project simply include it in your IDL file and refer to it using its name identifier: @extern \"mylib.yaml\" client_interface = interface +c { foo(): mylib_record1; }","title":"Usage"},{"location":"djinni-generator/modularization/#defining-custom-types","text":"The YAML files can be created by hand as long as you follow the required format. This allows you to support types not generated by Djinni. See duration.yaml and the accompanying translators in Duration-objc.hpp , Duration-jni.hpp and Duration-cs.hpp for an advanced example. Handwritten translators implement the following concept: // For C++ <-> Objective-C struct Record1 { using CppType = :: mylib :: Record1 ; using ObjcType = MLBRecord1 * ; static CppType toCpp ( ObjcType o ) { return /* your magic here */ ; } static ObjcType fromCpp ( CppType c ) { return /* your magic here */ ; } // Option 1: use this if no boxing is required using Boxed = Record1 ; // Option 2: or this if you do need dedicated boxing behavior struct Boxed { using ObjcType = MLBRecord1Special * ; static CppType toCpp ( ObjcType o ) { return /* your magic here */ ; } static ObjcType fromCpp ( CppType c ) { return /* your magic here */ ; } } }; // For C++ <-> JNI #include \"djinni_support.hpp\" struct Record1 { using CppType = :: mylib :: Record1 ; using JniType = jobject ; static CppType toCpp ( JniType j ) { return /* your magic here */ ; } // The return type *must* be LocalRef<T> if T is not a primitive! static :: djinni :: LocalRef < jobject > JniType fromCpp ( CppType c ) { return /* your magic here */ ; } using Boxed = Record1 ; }; // For C++ <-> C++/CLI public ref class Record1 { public : // Record1 public properties internal : using CppType = :: mylib :: Record1 ; using CsType = Record1 ^ ; static CppType ToCpp ( CsType cs ) { return /* your magic here */ ; } static CsType FromCpp ( const CppType & cs ) { return /* your magic here */ ; } private : // Record1 properties' backing fields } For interface classes the CppType alias is expected to be a std::shared_ptr<T> . Be sure to put the translators into representative and distinct namespaces. If your type is generic the translator takes the same number of template parameters. At usage each is instantiated with the translators of the respective type argument. template < class A , class B > struct Record1 { using CppType = :: mylib :: Record1 < typename A :: CppType , typename B :: CppType > ; using ObjcType = MLBRecord1 * ; static CppType toCpp ( ObjcType o ) { // Use A::toCpp() and B::toCpp() if necessary return /* your magic here */ ; } static ObjcType fromCpp ( CppType c ) { // Use A::fromCpp() and B::fromCpp() if necessary return /* your magic here */ ; } using Boxed = Record1 ; };","title":"Defining custom types"},{"location":"djinni-generator/setup/","text":"Generator Setup \u00b6 Installation \u00b6 Important The generator requires Java ! Linux, macOS \u00b6 Manually \u00b6 Install with asdf \u00b6 asdf plugin add djinni asdf install djinni latest Windows \u00b6 Conan \u00b6 The generator is available at conan-center for Windows, Linux & macOS. Add the generator as a build requirement in conanfile.txt : [build_requires] djinni-generator/1.0.0","title":"Generator Setup"},{"location":"djinni-generator/setup/#generator-setup","text":"","title":"Generator Setup"},{"location":"djinni-generator/setup/#installation","text":"Important The generator requires Java !","title":"Installation"},{"location":"djinni-generator/setup/#linux-macos","text":"","title":"Linux, macOS"},{"location":"djinni-generator/setup/#manually","text":"","title":"Manually"},{"location":"djinni-generator/setup/#install-with-asdf","text":"asdf plugin add djinni asdf install djinni latest","title":"Install with asdf"},{"location":"djinni-generator/setup/#windows","text":"","title":"Windows"},{"location":"djinni-generator/setup/#conan","text":"The generator is available at conan-center for Windows, Linux & macOS. Add the generator as a build requirement in conanfile.txt : [build_requires] djinni-generator/1.0.0","title":"Conan"},{"location":"djinni-intellij-plugin/","text":"About IntelliJ IDEA Plugin \u00b6 Adds basic navigation, code-completion and error highlighting support for .djinni IDL files. Get the plugin in the Jetbrains Marketplace:","title":"About IntelliJ IDEA Plugin"},{"location":"djinni-intellij-plugin/#about-intellij-idea-plugin","text":"Adds basic navigation, code-completion and error highlighting support for .djinni IDL files. Get the plugin in the Jetbrains Marketplace:","title":"About IntelliJ IDEA Plugin"},{"location":"djinni-intellij-plugin/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only of interest if you want to make changes to the code of the intellij plugin! Development Basics \u00b6 Build \u00b6 To build on your local machine, run the buildPlugin task ./gradlew buildPlugin Debug \u00b6 With the runIde task you can run the plugin in an isolated IDE and get logs about whats going on. Install \u00b6 To install the plugin you just built locally, go to Preferences > Plugins > Marketplace > \u2699 > Install plugin from disk... You can find the built plugin package under build/distributions/djinni-intellij-plugin-<version>.zip Adjusting grammar \u00b6 The grammar for .djinni files is defined in Backus\u2013Naur form in Djinni.bnf If you decide to make changes to this file, the following manual steps are required to apply them: Djinni.bnf : Right-Click > Generate Parser Code Right-Click > Generate JFlex Lexer , in the file dialog click Save and Replace _DjinniLexer.flex : Right-Click > Run JFlex Generator Release process \u00b6 To release a new plugin version, the following steps must be followed: Create a new release on Github like described here . Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. Github will automatically build the plugin, publish it to the jetbrains marketplace & upload the plugin-artifact to the release. The update will be verified by Jetbrains within a few days. Then it will be distributed to the users.","title":"Developer Guide"},{"location":"djinni-intellij-plugin/developer-guide/#developer-guide","text":"Info This chapter is only of interest if you want to make changes to the code of the intellij plugin!","title":"Developer Guide"},{"location":"djinni-intellij-plugin/developer-guide/#development-basics","text":"","title":"Development Basics"},{"location":"djinni-intellij-plugin/developer-guide/#build","text":"To build on your local machine, run the buildPlugin task ./gradlew buildPlugin","title":"Build"},{"location":"djinni-intellij-plugin/developer-guide/#debug","text":"With the runIde task you can run the plugin in an isolated IDE and get logs about whats going on.","title":"Debug"},{"location":"djinni-intellij-plugin/developer-guide/#install","text":"To install the plugin you just built locally, go to Preferences > Plugins > Marketplace > \u2699 > Install plugin from disk... You can find the built plugin package under build/distributions/djinni-intellij-plugin-<version>.zip","title":"Install"},{"location":"djinni-intellij-plugin/developer-guide/#adjusting-grammar","text":"The grammar for .djinni files is defined in Backus\u2013Naur form in Djinni.bnf If you decide to make changes to this file, the following manual steps are required to apply them: Djinni.bnf : Right-Click > Generate Parser Code Right-Click > Generate JFlex Lexer , in the file dialog click Save and Replace _DjinniLexer.flex : Right-Click > Run JFlex Generator","title":"Adjusting grammar"},{"location":"djinni-intellij-plugin/developer-guide/#release-process","text":"To release a new plugin version, the following steps must be followed: Create a new release on Github like described here . Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. Github will automatically build the plugin, publish it to the jetbrains marketplace & upload the plugin-artifact to the release. The update will be verified by Jetbrains within a few days. Then it will be distributed to the users.","title":"Release process"},{"location":"djinni-support-lib/developer-guide/","text":"Developer guide \u00b6 Info This chapter is only interesting if you intend to make changes to the code of djinni-support-lib Building from source \u00b6 Build dependencies \u00b6 Djinni generator (compatible version specified in .tool-versions ) Java JDK 8 or 11 Building \u00b6 Make sure you have the JAVA_HOME environment variable properly set, e.g.: export JAVA_HOME = $( /usr/libexec/java_home ) For an out of source build: mkdir -p build && cd build cmake -DDJINNI_WITH_JNI = 1 -DDJINNI_WITH_OBJC = 1 .. cmake --build . --parallel A custom djinni executable can be specified with the CMake option DJINNI_EXECUTABLE_PATH . Running Tests \u00b6 Java, Objective-C \u00b6 cd build/test-suite ctest C \u00b6 Generate Visual Studio Solution with -G \"Visual Studio 16 2019\" : cmake -S . -B build -DDJINNI_WITH_CPPCLI = ON -DDJINNI_STATIC_LIB = ON -G \"Visual Studio 16 2019\" Open the solution djinni_support_lib.sln in Visual Studio. Build DjinniCppCliTest . Run the tests: Test > Run All Tests . Release process \u00b6 To release a new version of the support-lib, the following steps must be followed: Create a new release on Github like described here . Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Create a PR to the conan-center-index to publish the new version to Conan Center .","title":"Developer guide"},{"location":"djinni-support-lib/developer-guide/#developer-guide","text":"Info This chapter is only interesting if you intend to make changes to the code of djinni-support-lib","title":"Developer guide"},{"location":"djinni-support-lib/developer-guide/#building-from-source","text":"","title":"Building from source"},{"location":"djinni-support-lib/developer-guide/#build-dependencies","text":"Djinni generator (compatible version specified in .tool-versions ) Java JDK 8 or 11","title":"Build dependencies"},{"location":"djinni-support-lib/developer-guide/#building","text":"Make sure you have the JAVA_HOME environment variable properly set, e.g.: export JAVA_HOME = $( /usr/libexec/java_home ) For an out of source build: mkdir -p build && cd build cmake -DDJINNI_WITH_JNI = 1 -DDJINNI_WITH_OBJC = 1 .. cmake --build . --parallel A custom djinni executable can be specified with the CMake option DJINNI_EXECUTABLE_PATH .","title":"Building"},{"location":"djinni-support-lib/developer-guide/#running-tests","text":"","title":"Running Tests"},{"location":"djinni-support-lib/developer-guide/#java-objective-c","text":"cd build/test-suite ctest","title":"Java, Objective-C"},{"location":"djinni-support-lib/developer-guide/#c","text":"Generate Visual Studio Solution with -G \"Visual Studio 16 2019\" : cmake -S . -B build -DDJINNI_WITH_CPPCLI = ON -DDJINNI_STATIC_LIB = ON -G \"Visual Studio 16 2019\" Open the solution djinni_support_lib.sln in Visual Studio. Build DjinniCppCliTest . Run the tests: Test > Run All Tests .","title":"C"},{"location":"djinni-support-lib/developer-guide/#release-process","text":"To release a new version of the support-lib, the following steps must be followed: Create a new release on Github like described here . Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Create a PR to the conan-center-index to publish the new version to Conan Center .","title":"Release process"},{"location":"djinni-support-lib/install/","text":"Installing the Support-Lib \u00b6 Conan \u00b6 The library is available at conan-center : [requires] djinni-support-lib/0.0.1 Options \u00b6 Option Values Description shared True , False Wether to build as shared library. Default: False fPIC True , False Default: True . Follows the default Conan behaviour. target jni , objc , auto The library has different targets for usage with Java or Objective-C. By default ( auto ) the target is determined automatically depending on the target OS ( iOS \u2192 objc , Android \u2192 jni ). Set this explicitly if you want to build for macOS / Windows / Linux , because on these platforms both targets may be a valid option! system_java True , False The library needs to link against the JNI (Java Native Interface) if target is jni . By default ( True ), zulu-openjdk/11.0.8 will be installed from conan center for this. Set to False to use the systems Java installation instead.","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#installing-the-support-lib","text":"","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#conan","text":"The library is available at conan-center : [requires] djinni-support-lib/0.0.1","title":"Conan"},{"location":"djinni-support-lib/install/#options","text":"Option Values Description shared True , False Wether to build as shared library. Default: False fPIC True , False Default: True . Follows the default Conan behaviour. target jni , objc , auto The library has different targets for usage with Java or Objective-C. By default ( auto ) the target is determined automatically depending on the target OS ( iOS \u2192 objc , Android \u2192 jni ). Set this explicitly if you want to build for macOS / Windows / Linux , because on these platforms both targets may be a valid option! system_java True , False The library needs to link against the JNI (Java Native Interface) if target is jni . By default ( True ), zulu-openjdk/11.0.8 will be installed from conan center for this. Set to False to use the systems Java installation instead.","title":"Options"},{"location":"djinni-support-lib/python-support/","text":"Python Support \u00b6 Python support in Djinni is experimental, but ready to try out. It can generate code for bridging C++ with Python 3. For more information, you can check out the talk from CppCon 2015. Slides and video are avilable online. Pre-requisites \u00b6 Djinni generates code which should work with Python 3. Python support has only been tested on macOS with the clang compiler. ~~It's been designed to work on any platform, and the known issues are in the build scripts rather than the generated code itself.~~ (We're now using CMake to build all bindings but it still requires testing in platforms other than macOS.) The Python support generated by Djinni makes use of a few non-default Python extensions, as does the test suite. You can install them as follows: sudo pip3 install cffi sudo pip3 install future sudo pip3 install pytest Test Suite \u00b6 Because of the known limitations described below, the Python test suite does not use all of the same inputs as the other languages. As a result, you'll see a separate pycpp directory in generated-src. This contains output of the standard C++ generator, but for the specific input files used by the Python test suite. Known limitations \u00b6 Proxy caching is not yet implemented. In addition to some inefficiency, this means that the same object passed across the language boundary twice is not guaranteed to appear as a single object on the other side. The support library code makes direct reference to types rather than respecting the command-line choice of a different optional library.","title":"Python Support"},{"location":"djinni-support-lib/python-support/#python-support","text":"Python support in Djinni is experimental, but ready to try out. It can generate code for bridging C++ with Python 3. For more information, you can check out the talk from CppCon 2015. Slides and video are avilable online.","title":"Python Support"},{"location":"djinni-support-lib/python-support/#pre-requisites","text":"Djinni generates code which should work with Python 3. Python support has only been tested on macOS with the clang compiler. ~~It's been designed to work on any platform, and the known issues are in the build scripts rather than the generated code itself.~~ (We're now using CMake to build all bindings but it still requires testing in platforms other than macOS.) The Python support generated by Djinni makes use of a few non-default Python extensions, as does the test suite. You can install them as follows: sudo pip3 install cffi sudo pip3 install future sudo pip3 install pytest","title":"Pre-requisites"},{"location":"djinni-support-lib/python-support/#test-suite","text":"Because of the known limitations described below, the Python test suite does not use all of the same inputs as the other languages. As a result, you'll see a separate pycpp directory in generated-src. This contains output of the standard C++ generator, but for the specific input files used by the Python test suite.","title":"Test Suite"},{"location":"djinni-support-lib/python-support/#known-limitations","text":"Proxy caching is not yet implemented. In addition to some inefficiency, this means that the same object passed across the language boundary twice is not guaranteed to appear as a single object on the other side. The support library code makes direct reference to types rather than respecting the command-line choice of a different optional library.","title":"Known limitations"},{"location":"vscode-djinni/","text":"About VS Code Extension \u00b6 Adds really basic syntax highlighting for djinni interface files. Get the extension in the Visual Studio Marketplace","title":"About VS Code Extension"},{"location":"vscode-djinni/#about-vs-code-extension","text":"Adds really basic syntax highlighting for djinni interface files. Get the extension in the Visual Studio Marketplace","title":"About VS Code Extension"},{"location":"vscode-djinni/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only of interest if you want to make changes to the code of the vscode extension! Development Basics \u00b6 Build dependencies \u00b6 node npm Building \u00b6 npm install # installs all required dependencies npm run package # builds the .vsix package Github Release Process \u00b6 To release a new extension version, the following steps must be followed: Create a new release on Github like described here . Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. Github will automatically build the extension, publish it to the Visual Studio Marketplace & upload the packaged extension to the release. That's it!","title":"Developer Guide"},{"location":"vscode-djinni/developer-guide/#developer-guide","text":"Info This chapter is only of interest if you want to make changes to the code of the vscode extension!","title":"Developer Guide"},{"location":"vscode-djinni/developer-guide/#development-basics","text":"","title":"Development Basics"},{"location":"vscode-djinni/developer-guide/#build-dependencies","text":"node npm","title":"Build dependencies"},{"location":"vscode-djinni/developer-guide/#building","text":"npm install # installs all required dependencies npm run package # builds the .vsix package","title":"Building"},{"location":"vscode-djinni/developer-guide/#github-release-process","text":"To release a new extension version, the following steps must be followed: Create a new release on Github like described here . Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. Github will automatically build the extension, publish it to the Visual Studio Marketplace & upload the packaged extension to the release. That's it!","title":"Github Release Process"}]}