{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple IDL \u00b6 The Djinni-IDL provides a simple, yet powerful way to design your interfaces. IDE Integration \u00b6 Plugins for the Djinni IDL are available for IntelliJ IDEA & VS Code Ready for the Future \u00b6 Djinni is also compatible with modern technologies. Call your C++ Code from Kotlin and Swift to have even more fun! Works in both directions \u00b6 Call in and out of C++ with ease:","title":"Home"},{"location":"#simple-idl","text":"The Djinni-IDL provides a simple, yet powerful way to design your interfaces.","title":"Simple IDL"},{"location":"#ide-integration","text":"Plugins for the Djinni IDL are available for IntelliJ IDEA & VS Code","title":"IDE Integration"},{"location":"#ready-for-the-future","text":"Djinni is also compatible with modern technologies. Call your C++ Code from Kotlin and Swift to have even more fun!","title":"Ready for the Future"},{"location":"#works-in-both-directions","text":"Call in and out of C++ with ease:","title":"Works in both directions"},{"location":"contributing/","text":"Contributing \u00b6 The cross-language-cpp project \u00b6 Cross-language-cpp is driven by individual people on a volunteer base. The idea for this project has been born at the Mobile C++ slack channel. Motivation \u00b6 Already before the sunset of the original djinni project it was not possible anymore to contribute to the project. A lot of ideas, bug fixes and new features have not been reported or submitted upstream. They are either available in various personal forks of djinni, or not available at all. Just to name an example, there are various javascript/nodejs implementation for djinni out there. They are all in personal forks, Often these project do not even know from each other. This is not optimal. Goals \u00b6 Continuation of the development of djinni and it's related tools. Avoid a single point of failure for the project. The goal is to have enough maintainers so the project will always have some administrator, and a read only state like the original project can be avoided. Be the place where new ideas and improvements to djinni and it's tools are collected and implemented. Becoming involved in the project \u00b6 As any open source project, we depend on the work of people that contribute to the project. Contributing to the project \u00b6 As mentioned, there have been various extension and additions to djinni been made. But most creators say the same: This is just a personal extension, a fast hack to make something work, not good enough for public release. These are all common reasons for not publishing code, and we think that they are not correct or should not be an impediment for not pushing changes back upstream. Release early, release often, if something is not good enough, it will either be not used or fixed. Open source evolution will care about. But the essential requirement is, make the changes available. There is nothing to lose, but everything to win! Becoming a maintainer \u00b6 As mentioned, one of the goals of the project is to establish a structure that ensures the availability of the project over time. For this to happen, maintainers are needed! For being a maintainer, we think the following points are important: Be available and responsive (as your time allows) : Respond in time to user request, or just be there when your time allows it. A reply I do not know now but I will come back is better than no reply for people that visit the project. Be reliable : If you admit to do something, please do not disappear without any notice. Be consistent (for some time) : It is common that people pop in full with ideas and energy, and this is great and such people are usual great contributors! But for a maintainer role it is also important to be consistent for more than just a few days or until 1 issue is realized or solved. No one expects commitment of a live time, but by taking a maintainer maybe for more than one week.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#the-cross-language-cpp-project","text":"Cross-language-cpp is driven by individual people on a volunteer base. The idea for this project has been born at the Mobile C++ slack channel.","title":"The cross-language-cpp project"},{"location":"contributing/#motivation","text":"Already before the sunset of the original djinni project it was not possible anymore to contribute to the project. A lot of ideas, bug fixes and new features have not been reported or submitted upstream. They are either available in various personal forks of djinni, or not available at all. Just to name an example, there are various javascript/nodejs implementation for djinni out there. They are all in personal forks, Often these project do not even know from each other. This is not optimal.","title":"Motivation"},{"location":"contributing/#goals","text":"Continuation of the development of djinni and it's related tools. Avoid a single point of failure for the project. The goal is to have enough maintainers so the project will always have some administrator, and a read only state like the original project can be avoided. Be the place where new ideas and improvements to djinni and it's tools are collected and implemented.","title":"Goals"},{"location":"contributing/#becoming-involved-in-the-project","text":"As any open source project, we depend on the work of people that contribute to the project.","title":"Becoming involved in the project"},{"location":"contributing/#contributing-to-the-project","text":"As mentioned, there have been various extension and additions to djinni been made. But most creators say the same: This is just a personal extension, a fast hack to make something work, not good enough for public release. These are all common reasons for not publishing code, and we think that they are not correct or should not be an impediment for not pushing changes back upstream. Release early, release often, if something is not good enough, it will either be not used or fixed. Open source evolution will care about. But the essential requirement is, make the changes available. There is nothing to lose, but everything to win!","title":"Contributing to the project"},{"location":"contributing/#becoming-a-maintainer","text":"As mentioned, one of the goals of the project is to establish a structure that ensures the availability of the project over time. For this to happen, maintainers are needed! For being a maintainer, we think the following points are important: Be available and responsive (as your time allows) : Respond in time to user request, or just be there when your time allows it. A reply I do not know now but I will come back is better than no reply for people that visit the project. Be reliable : If you admit to do something, please do not disappear without any notice. Be consistent (for some time) : It is common that people pop in full with ideas and energy, and this is great and such people are usual great contributors! But for a maintainer role it is also important to be consistent for more than just a few days or until 1 issue is realized or solved. No one expects commitment of a live time, but by taking a maintainer maybe for more than one week.","title":"Becoming a maintainer"},{"location":"example/","text":"Example \u00b6 iOS \u00b6 TODO Android \u00b6 TODO","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#ios","text":"TODO","title":"iOS"},{"location":"example/#android","text":"TODO","title":"Android"},{"location":"icon_resources/","text":"Djinni Logo Resources \u00b6 The cross-language-cpp djinni has a new, unique logo. If you want to report about or reference to our project, please make sure to use the official logo resources: Icon (800x800) Full Logo (1189 x 500) Affinity Designer Resource file","title":"Djinni Logo Resources"},{"location":"icon_resources/#djinni-logo-resources","text":"The cross-language-cpp djinni has a new, unique logo. If you want to report about or reference to our project, please make sure to use the official logo resources: Icon (800x800) Full Logo (1189 x 500) Affinity Designer Resource file","title":"Djinni Logo Resources"},{"location":"overview/","text":"Overview \u00b6 What is djinni? \u00b6 Djinni is a tool for generating cross-language type declarations and interface bindings to connect C++ with either Java or Objective-C. Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Djinni was announced by Dropbox at CppCon 2014: Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project! We are currently in the early stage of migration to the all new cross-language-cpp organization. ( More Information... ) How the magic works \u00b6 To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from an interface definition language (IDL) . All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and managing memory. Example: Call C++ Code from Java or Objective-C This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static create(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Example: Call Java/Objective-C Code from C++ This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ; Main Features \u00b6 Generates parallel C++, Java and Objective-C type definitions from a single interface description file. Supports the intersection of the three core languages' primitive types, and user-defined enums, flags, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++). Can autogenerate comparator functions (equality, ordering) on data types. Components of Djinni \u00b6 Djinni consists of 2 important components: Generator : Command-line tool that takes an IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#what-is-djinni","text":"Djinni is a tool for generating cross-language type declarations and interface bindings to connect C++ with either Java or Objective-C. Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Djinni was announced by Dropbox at CppCon 2014: Djinni \u2764\ufe0f Community! Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project! We are currently in the early stage of migration to the all new cross-language-cpp organization. ( More Information... )","title":"What is djinni?"},{"location":"overview/#how-the-magic-works","text":"To call from one programming language to another, usually a lot of gluecode is required. Djinni automatically generates this gluecode from an interface definition language (IDL) . All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and managing memory. Example: Call C++ Code from Java or Objective-C This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C: HelloWorld = interface +c { static create(): HelloWorld; fromCpp(): string } Implemented in C++ #include \"djinni/generated/HelloWorld.hpp\" class HelloWorldImpl : public HelloWorld { public : static std :: shared_ptr < HelloWorld > create () { return std :: make_shared < HelloWorldImpl > (); } std :: string fromCpp () { return \"Hello From C++!\" ; } } Called from Java HelloWorld helloWorld = HelloWorld . create (); System . out . println ( helloWorld . fromCpp ()); // Hello from C++! or Objective-C HelloWorld * helloWorld = [ HelloWorld create ]; NSLog ([ helloWorld fromCpp ]); // Hello from C++! Example: Call Java/Objective-C Code from C++ This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++: HelloWorld = interface +j +o { fromLanguage(): string; } Implemented in Java public class HelloWorldJava extends HelloWorld { @Override String fromLanguage () { return \"from Java\" ; } } or Objective-C @interface HelloWorldObjC : NSObject < HelloWorld > - ( NSString ) fromLanguage ; @end @implementation HelloWorldObjC - ( NSString ) fromLanguage { return \"from Objective-C\" ; } @end Called from C++ std :: cout << helloWorldInstance -> fromLanguage () << std :: endl ;","title":"How the magic works"},{"location":"overview/#main-features","text":"Generates parallel C++, Java and Objective-C type definitions from a single interface description file. Supports the intersection of the three core languages' primitive types, and user-defined enums, flags, records, and interfaces. Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++). Can autogenerate comparator functions (equality, ordering) on data types.","title":"Main Features"},{"location":"overview/#components-of-djinni","text":"Djinni consists of 2 important components: Generator : Command-line tool that takes an IDL file as input and generates the gluecode. Support lib : Library that is required for the gluecode to work.","title":"Components of Djinni"},{"location":"setup/","text":"Setup \u00b6 The following steps are required to get you started: 1. Installation of Generator \u00b6 Get the latest version of the generator from github . Go here for more detailed install instructions. 2. Add the support-lib to your project \u00b6 The support-lib will be available for multiple package managers soon. Stay tuned! Go here for more detailed install instructions. 3. Install IDE Plugin \u00b6 For syntax checking and highlighting of the Djinni-IDL install the plugin for your IDE: VS Code : ( download ) IntelliJ IDEA : ( download , documentation )","title":"Setup"},{"location":"setup/#setup","text":"The following steps are required to get you started:","title":"Setup"},{"location":"setup/#1-installation-of-generator","text":"Get the latest version of the generator from github . Go here for more detailed install instructions.","title":"1. Installation of Generator"},{"location":"setup/#2-add-the-support-lib-to-your-project","text":"The support-lib will be available for multiple package managers soon. Stay tuned! Go here for more detailed install instructions.","title":"2. Add the support-lib to your project"},{"location":"setup/#3-install-ide-plugin","text":"For syntax checking and highlighting of the Djinni-IDL install the plugin for your IDE: VS Code : ( download ) IntelliJ IDEA : ( download , documentation )","title":"3. Install IDE Plugin"},{"location":"djinni-generator/cli-usage/","text":"Using the Generator \u00b6 When the Djinni file(s) are ready, from the command line you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --py-out PYTHON_OUTPUT_FOLDER \\ --pycffi-out CFFI_OUTPUT_FOLDER \\ # Required for Python support --pycffi-package-name PyCFFIlib \\ --pycffi-dynamic-lib-list mylib \\ --c-wrapper-out C_WRAPPER_OUTPUT_FOLDER \\ # Required for Python support \\ --idl MY_PROJECT.djinni Note If a language's output folder is not specified, that language will not be generated. All Arguments \u00b6 General \u00b6 Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import directives. Can specify multiple paths. Java \u00b6 Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false ). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ). C++ \u00b6 Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false ) JNI \u00b6 Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base support library's include path (default: djinni/jni/ ). Objective-C \u00b6 Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-header-out <out-folder> The output folder for Objective-C header files (default: the same as --objc-out ). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. The output folder is --objc-header-out . --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ). Objective-C++ \u00b6 Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C base support library's include path (default: djinni/objc/ ). Python \u00b6 Argument Description --py-out <out-folder> The output folder for Python files (Generator disabled if unspecified). --pycffi-out <out-folder> The output folder for PyCFFI files (Generator disabled if unspecified). --pycffi-package-name ... The package name to use for the generated PyCFFI classes. --pycffi-dynamic-lib-list ... The names of the dynamic libraries to be linked with PyCFFI. --c-wrapper-out <out-folder> The output folder for C wrapper files (Generator disabled if unspecified). --c-wrapper-header-out <out-folder> The output folder for C wrapper header files (default: the same as --c-wrapper-out ). --c-wrapper-include-prefix <prefix> The prefix for #includes of C wrapper header files from C wrapper C++ files. --c-wrapper-include-cpp-prefix <prefix> The prefix for #includes of C++ header files from C wrapper C++ files. --c-wrapper-base-lib-include-prefix <prefix> The C wrapper base support library's include path (default: djinni/cwrapper/ ). --py-import-prefix <import-prefix> The import prefix used within python generated files (default: \"\") Yaml Generation \u00b6 Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\"). Other \u00b6 Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false ) Identifier Style \u00b6 The Identifier Style is a text conversion hint on how to generate names from the djinni idl file. Possible values: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar . C++ \u00b6 Argument Default --ident-cpp-enum FOO_BAR --ident-cpp-field foo_bar --ident-cpp-method foo_bar --ident-cpp-type FooBar --ident-cpp-enum-type FooBar --ident-cpp-type-param FooBar --ident-cpp-local foo_bar --ident-cpp-file foo_bar Java \u00b6 Argument Default --ident-java-enum FOO_BAR --ident-java-field fooBar --ident-java-type FooBar --ident-jni-class FooBar --ident-jni-file foo_bar Objective C \u00b6 Argument Default --ident-objc-enum FooBar --ident-objc-field fooBar --ident-objc-method fooBar --ident-objc-type FooBar --ident-objc-type-param FooBar --ident-objc-local fooBar --ident-objc-file FooBar Python \u00b6 Argument Default --ident-py-type foo_bar --ident-py-class-name FooBar --ident-py-type-param foo_bar --ident-py-method foo_bar --ident-py-field foo_bar --ident-py-local foo_bar --ident-py-enum Foo_Bar --ident-py-const FOO_BAR Example: The djinni idl for an enum SomeEnum = enum { Value; } transforms per default to the following Java code public enum SomeEnum { VALUE, ; } As you see, VALUE is now in upper case letters. If you use --ident-java-enum foo_bar then Value will not be transformed into upper case and the following Java code will be generated. public enum SomeEnum { Value, ; } This way you can adopt code generation to some extend to your existing coding style. The best way to find out how that works is playing around with different values for different identifier options. If you wish no text transformation to happen, use the foo_bar style. Note Some identifiers do have text transformation enabled by default. Nevertheless make sure to explicitly set text transformation styles if you need them! All text transformation may be disabled by default in a future release of the generator.","title":"Using the Generator"},{"location":"djinni-generator/cli-usage/#using-the-generator","text":"When the Djinni file(s) are ready, from the command line you can run: djinni \\ --java-out JAVA_OUTPUT_FOLDER \\ --java-package com.example.jnigenpackage \\ --java-cpp-exception DbxException \\ # Choose between a customized C++ exception in Java and java.lang.RuntimeException (the default). --ident-java-field mFooBar \\ # Optional, this adds an \"m\" in front of Java field names \\ --cpp-out CPP_OUTPUT_FOLDER \\ \\ --jni-out JNI_OUTPUT_FOLDER \\ --ident-jni-class NativeFooBar \\ # This adds a \"Native\" prefix to JNI class --ident-jni-file NativeFooBar \\ # This adds a prefix to the JNI filenames otherwise the cpp and jni filenames are the same. \\ --objc-out OBJC_OUTPUT_FOLDER \\ --objc-type-prefix DB \\ # Apple suggests Objective-C classes have a prefix for each defined type. \\ --objcpp-out OBJC_OUTPUT_FOLDER \\ \\ --py-out PYTHON_OUTPUT_FOLDER \\ --pycffi-out CFFI_OUTPUT_FOLDER \\ # Required for Python support --pycffi-package-name PyCFFIlib \\ --pycffi-dynamic-lib-list mylib \\ --c-wrapper-out C_WRAPPER_OUTPUT_FOLDER \\ # Required for Python support \\ --idl MY_PROJECT.djinni Note If a language's output folder is not specified, that language will not be generated.","title":"Using the Generator"},{"location":"djinni-generator/cli-usage/#all-arguments","text":"","title":"All Arguments"},{"location":"djinni-generator/cli-usage/#general","text":"Argument Description --help Print help --version Print version --idl <in-file> The IDL file with the type definitions, typically with extension .djinni . --idl-include-path <path> ... An include path to search for Djinni @import directives. Can specify multiple paths.","title":"General"},{"location":"djinni-generator/cli-usage/#java","text":"Argument Description --java-out <out-folder> The output for the Java files (Generator disabled if unspecified). --java-package ... The package name to use for generated Java classes. --java-class-access-modifier <public/package> The access modifier to use for generated Java classes (default: public ). --java-cpp-exception <exception-class> The type for translated C++ exceptions in Java (default: java.lang.RuntimeException that is not checked) --java-annotation <annotation-class> Java annotation ( @Foo ) to place on all generated Java classes --java-generate-interfaces <true/false> Whether Java interfaces should be used instead of abstract classes where possible (default: false ). --java-nullable-annotation <nullable-annotation-class> Java annotation ( @Nullable ) to place on all fields and return values that are optional --java-nonnull-annotation <nonnull-annotation-class> Java annotation ( @Nonnull ) to place on all fields and return values that are not optional --java-implement-android-os-parcelable <true/false> all generated java classes will implement the interface android.os.Parcelable --java-use-final-for-record <use-final-for-record> Whether generated Java classes for records should be marked final (default: true ).","title":"Java"},{"location":"djinni-generator/cli-usage/#c","text":"Argument Description --cpp-out <out-folder> The output folder for C++ files (Generator disabled if unspecified). --cpp-header-out <out-folder> The output folder for C++ header files (default: the same as --cpp-out ). --cpp-include-prefix <prefix> The prefix for #includes of header files from C++ files. --cpp-namespace ... The namespace name to use for generated C++ classes. --cpp-ext <ext> The filename extension for C++ files (default: cpp ). --hpp-ext <ext> The filename extension for C++ header files (default: hpp ). --cpp-optional-template <template> The template to use for optional values (default: std::optional ) --cpp-optional-header <header> The header to use for optional values (default: <optional> ) --cpp-enum-hash-workaround <true/false> Work around LWG-2148 by generating std::hash specializations for C++ enums (default: true ) --cpp-nn-header <header> The header to use for non-nullable pointers --cpp-nn-type <header> The type to use for non-nullable pointers (as a substitute for std::shared_ptr ) --cpp-nn-check-expression <header> The expression to use for building non-nullable pointers --cpp-use-wide-strings <true/false> Use wide strings in C++ code (default: false )","title":"C++"},{"location":"djinni-generator/cli-usage/#jni","text":"Argument Description --jni-out <out-folder> The folder for the JNI C++ output files (Generator disabled if unspecified). --jni-header-out <out-folder> The folder for the JNI C++ header files (default: the same as --jni-out ). --jni-include-prefix <prefix> The prefix for #includes of JNI header files from JNI C++ files. --jni-include-cpp-prefix <prefix> The prefix for #includes of the main header files from JNI C++ files. --jni-namespace ... The namespace name to use for generated JNI C++ classes. --jni-base-lib-include-prefix ... The JNI base support library's include path (default: djinni/jni/ ).","title":"JNI"},{"location":"djinni-generator/cli-usage/#objective-c","text":"Argument Description --objc-out <out-folder> The output folder for Objective-C files (Generator disabled if unspecified). --objc-header-out <out-folder> The output folder for Objective-C header files (default: the same as --objc-out ). --objc-h-ext <ext> The filename extension for Objective-C[++] header files (default: h ) --objc-type-prefix <pre> The prefix for Objective-C data types (usually two or three letters) --objc-include-prefix <prefix> The prefix for #import of header files from Objective-C files. --objc-swift-bridging-header <name> The name of Objective-C Bridging Header used in XCode's Swift projects. The output folder is --objc-header-out . --objc-closed-enums <true/false> All generated Objective-C enums will be NS_CLOSED_ENUM (default: false ).","title":"Objective-C"},{"location":"djinni-generator/cli-usage/#objective-c_1","text":"Argument Description --objcpp-out <out-folder> The output folder for private Objective-C++ files (Generator disabled if unspecified). --objcpp-ext <ext> The filename extension for Objective-C++ files (default: mm ) --objcpp-include-prefix <prefix> The prefix for #import of Objective-C++ header files from Objective-C++ files. --objcpp-include-cpp-prefix <prefix> The prefix for #include of the main C++ header files from Objective-C++ files. --objcpp-include-objc-prefix <prefix> The prefix for #import of the Objective-C header files from Objective-C++ files (default: the same as --objcpp-include-prefix ) --cpp-extended-record-include-prefix <prefix> The prefix path for #include of the extended record C++ header ( .hpp ) files --objc-extended-record-include-prefix <prefix> The prefix path for #import of the extended record Objective-C header ( .h ) files --objcpp-namespace <prefix> The namespace name to use for generated Objective-C++ classes. --objc-base-lib-include-prefix ... The Objective-C base support library's include path (default: djinni/objc/ ).","title":"Objective-C++"},{"location":"djinni-generator/cli-usage/#python","text":"Argument Description --py-out <out-folder> The output folder for Python files (Generator disabled if unspecified). --pycffi-out <out-folder> The output folder for PyCFFI files (Generator disabled if unspecified). --pycffi-package-name ... The package name to use for the generated PyCFFI classes. --pycffi-dynamic-lib-list ... The names of the dynamic libraries to be linked with PyCFFI. --c-wrapper-out <out-folder> The output folder for C wrapper files (Generator disabled if unspecified). --c-wrapper-header-out <out-folder> The output folder for C wrapper header files (default: the same as --c-wrapper-out ). --c-wrapper-include-prefix <prefix> The prefix for #includes of C wrapper header files from C wrapper C++ files. --c-wrapper-include-cpp-prefix <prefix> The prefix for #includes of C++ header files from C wrapper C++ files. --c-wrapper-base-lib-include-prefix <prefix> The C wrapper base support library's include path (default: djinni/cwrapper/ ). --py-import-prefix <import-prefix> The import prefix used within python generated files (default: \"\")","title":"Python"},{"location":"djinni-generator/cli-usage/#yaml-generation","text":"Argument Description --yaml-out <out-folder> The output folder for YAML files (Generator disabled if unspecified). --yaml-out-file <out-file> If specified all types are merged into a single YAML file instead of generating one file per type (relative to --yaml-out ). --yaml-prefix <pre> The prefix to add to type names stored in YAML files (default: \"\").","title":"Yaml Generation"},{"location":"djinni-generator/cli-usage/#other","text":"Argument Description --list-in-files <list-in-files> Optional file in which to write the list of input files parsed. --list-out-files <list-out-files> Optional file in which to write the list of output files produced. --skip-generation <true/false> Way of specifying if file generation should be skipped (default: false )","title":"Other"},{"location":"djinni-generator/cli-usage/#identifier-style","text":"The Identifier Style is a text conversion hint on how to generate names from the djinni idl file. Possible values: FooBar , fooBar , foo_bar , FOO_BAR , m_fooBar .","title":"Identifier Style"},{"location":"djinni-generator/cli-usage/#c_1","text":"Argument Default --ident-cpp-enum FOO_BAR --ident-cpp-field foo_bar --ident-cpp-method foo_bar --ident-cpp-type FooBar --ident-cpp-enum-type FooBar --ident-cpp-type-param FooBar --ident-cpp-local foo_bar --ident-cpp-file foo_bar","title":"C++"},{"location":"djinni-generator/cli-usage/#java_1","text":"Argument Default --ident-java-enum FOO_BAR --ident-java-field fooBar --ident-java-type FooBar --ident-jni-class FooBar --ident-jni-file foo_bar","title":"Java"},{"location":"djinni-generator/cli-usage/#objective-c_2","text":"Argument Default --ident-objc-enum FooBar --ident-objc-field fooBar --ident-objc-method fooBar --ident-objc-type FooBar --ident-objc-type-param FooBar --ident-objc-local fooBar --ident-objc-file FooBar","title":"Objective C"},{"location":"djinni-generator/cli-usage/#python_1","text":"Argument Default --ident-py-type foo_bar --ident-py-class-name FooBar --ident-py-type-param foo_bar --ident-py-method foo_bar --ident-py-field foo_bar --ident-py-local foo_bar --ident-py-enum Foo_Bar --ident-py-const FOO_BAR Example: The djinni idl for an enum SomeEnum = enum { Value; } transforms per default to the following Java code public enum SomeEnum { VALUE, ; } As you see, VALUE is now in upper case letters. If you use --ident-java-enum foo_bar then Value will not be transformed into upper case and the following Java code will be generated. public enum SomeEnum { Value, ; } This way you can adopt code generation to some extend to your existing coding style. The best way to find out how that works is playing around with different values for different identifier options. If you wish no text transformation to happen, use the foo_bar style. Note Some identifiers do have text transformation enabled by default. Nevertheless make sure to explicitly set text transformation styles if you need them! All text transformation may be disabled by default in a future release of the generator.","title":"Python"},{"location":"djinni-generator/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only interesting if you intend to make changes to the code of djinni generator Building from source \u00b6 Build dependencies \u00b6 Java JDK 8 or 11 sbt Building \u00b6 To build once: sbt compile To automatically re-build on every change, open the sbt shell & prefix compile with ~ $ sbt sbt:djinni> ~compile Running \u00b6 sbt \"run --idl input.djinni --cpp-out out/cpp --java-out out/java/src --jni-out out/java/jni --objc-out out/objc --py-out out/python --pycffi-out out/cffi --c-wrapper-out out/cwrapper\" sbt \"run --help\" # show all options It is important to put run and all arguments in \" , to be able to pass arguments to the executed jar! Running Tests \u00b6 sbt it:test Packaging \u00b6 Create a binary like the one that is published on github releases: sbt assembly This will generate a standalone, self-executing jar in target/bin . You can run the jar like this: ./djinni --help On Windows the file must be renamed to djinni.bat to make it executable. Attention The resulting binary still requires Java to be able to run! Details on how the self-executing jar works . Project Structure \u00b6 . \u251c\u2500\u2500 CODE_OF_CONDUCT.md (1) \u251c\u2500\u2500 LICENSE (2) \u251c\u2500\u2500 README.md (3) \u251c\u2500\u2500 build.sbt (4) \u251c\u2500\u2500 docs (5) \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 mkdocs.yml (6) \u251c\u2500\u2500 project (7) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 src (8) \u251c\u2500\u2500 it (9) \u2502 \u251c\u2500\u2500 resources (10) \u2502 \u2502 \u251c\u2500\u2500 expected (11) \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u2514\u2500\u2500 result (12) \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 scala \u2502 \u2514\u2500\u2500 djinni (13) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 main \u2514\u2500\u2500 scala \u2514\u2500\u2500 djinni (14) \u2514\u2500\u2500 ... Project Code of Conduct. Project License (Apache License). Readme file. Sbt build configuration. Documentation folder containing markdown documentation that will be rendered with MkDocs. MkDocs configuration. Will be included by the cross-language-cpp.github.io repository and published to djinni.xlcpp.dev . Sbt configuration. Sources folder. Integration testing directory. Resources for integration tests. Folder containing expected outcomes of the djinni generator. These files are matched against the real result of the generator in the integration tests. Folder that will be used for generator outputs in the integration tests. Files in here should not be checked in to source control. Folder containing the integration testing code. djinni-generator source code. Release process \u00b6 To release a new version of the generator, the following steps must be followed: Create a new release on Github. Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. The Github \"release\" Action will automatically build the project and upload the resulting binaries to the release. Create a PR to the conan-center-index to publish the new version to Conan Center .","title":"Developer Guide"},{"location":"djinni-generator/developer-guide/#developer-guide","text":"Info This chapter is only interesting if you intend to make changes to the code of djinni generator","title":"Developer Guide"},{"location":"djinni-generator/developer-guide/#building-from-source","text":"","title":"Building from source"},{"location":"djinni-generator/developer-guide/#build-dependencies","text":"Java JDK 8 or 11 sbt","title":"Build dependencies"},{"location":"djinni-generator/developer-guide/#building","text":"To build once: sbt compile To automatically re-build on every change, open the sbt shell & prefix compile with ~ $ sbt sbt:djinni> ~compile","title":"Building"},{"location":"djinni-generator/developer-guide/#running","text":"sbt \"run --idl input.djinni --cpp-out out/cpp --java-out out/java/src --jni-out out/java/jni --objc-out out/objc --py-out out/python --pycffi-out out/cffi --c-wrapper-out out/cwrapper\" sbt \"run --help\" # show all options It is important to put run and all arguments in \" , to be able to pass arguments to the executed jar!","title":"Running"},{"location":"djinni-generator/developer-guide/#running-tests","text":"sbt it:test","title":"Running Tests"},{"location":"djinni-generator/developer-guide/#packaging","text":"Create a binary like the one that is published on github releases: sbt assembly This will generate a standalone, self-executing jar in target/bin . You can run the jar like this: ./djinni --help On Windows the file must be renamed to djinni.bat to make it executable. Attention The resulting binary still requires Java to be able to run! Details on how the self-executing jar works .","title":"Packaging"},{"location":"djinni-generator/developer-guide/#project-structure","text":". \u251c\u2500\u2500 CODE_OF_CONDUCT.md (1) \u251c\u2500\u2500 LICENSE (2) \u251c\u2500\u2500 README.md (3) \u251c\u2500\u2500 build.sbt (4) \u251c\u2500\u2500 docs (5) \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 mkdocs.yml (6) \u251c\u2500\u2500 project (7) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 src (8) \u251c\u2500\u2500 it (9) \u2502 \u251c\u2500\u2500 resources (10) \u2502 \u2502 \u251c\u2500\u2500 expected (11) \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u2514\u2500\u2500 result (12) \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 scala \u2502 \u2514\u2500\u2500 djinni (13) \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 main \u2514\u2500\u2500 scala \u2514\u2500\u2500 djinni (14) \u2514\u2500\u2500 ... Project Code of Conduct. Project License (Apache License). Readme file. Sbt build configuration. Documentation folder containing markdown documentation that will be rendered with MkDocs. MkDocs configuration. Will be included by the cross-language-cpp.github.io repository and published to djinni.xlcpp.dev . Sbt configuration. Sources folder. Integration testing directory. Resources for integration tests. Folder containing expected outcomes of the djinni generator. These files are matched against the real result of the generator in the integration tests. Folder that will be used for generator outputs in the integration tests. Files in here should not be checked in to source control. Folder containing the integration testing code. djinni-generator source code.","title":"Project Structure"},{"location":"djinni-generator/developer-guide/#release-process","text":"To release a new version of the generator, the following steps must be followed: Create a new release on Github. Set a tag version following semantic versioning rules ( v<MAJOR>.<MINOR>.<PATCH> ) and describe what has changed in the new version. Wait. The Github \"release\" Action will automatically build the project and upload the resulting binaries to the release. Create a PR to the conan-center-index to publish the new version to Conan Center .","title":"Release process"},{"location":"djinni-generator/generated-code-usage/","text":"Use Generated Code \u00b6 Java / JNI / C++ Project \u00b6 Includes & Build target \u00b6 The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Add all generated source files to your build target, and link the C++ code against the djinni-support-lib . Our JNI approach \u00b6 JNI stands for Java Native Interface , an extension of the Java language to allow interop with native (C/C++) code or libraries. For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: class Main { static { System . loadLibrary ( \"YourLibraryName\" ); // The name of the library is specified in Android.mk / build.gradle / Makefile / CMakeLists.txt, // depending on your build system. } } If you package your native library in a jar, you can also use the NativeLibLoader to help unpack and load your lib(s). When a native library is called, JNI calls a special function called JNI_OnLoad . If your app doesn't use JNI except through Djinni, include djinni/jni/djinni_main.cpp . It defines default JNI_Onload and JNI_OnUnload functions for Djinni. If your app also includes a non-Djinni JNI interface, you'll need to define your own JNI_OnLoad and JNI_OnUnload functions. Objective-C / C++ Project \u00b6 Includes & Build Target \u00b6 Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm Generated only for types that contain constants. Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, and link against the djinni-support-lib . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface. Python / C++ Project (Experimental) \u00b6 Python support in Djinni is experimental, but ready to try out. It can generate code for bridging C++ with Python 3. For more information, you can check out the talk from CppCon 2015. Slides and video are available online. Includes & Build Target \u00b6 When bridging to Python, Djinni generates 4 types of output: python Generated Python classes and proxies for interacting with C++ via CFFI . cffi Python code run at build time to create a Python extension out of the C++ code. cwrapper A C interface implemented in C++ to allowing Python to interact with C++ classes. cpp The same C++ classes generated for all other Djinni languages. Generated files for Python / C++ are as follows: Type C++ header C++ source Python files CFFI C Wrapper Enum/Flags my_enum.hpp my_enum.py dh__my_enum.cpp dh__my_enum.h dh__my_enum.hpp Record my_record[_base].hpp my_record[_base].cpp my_record[_base].py dh__my_record.cpp dh__my_record.h dh__my_record.hpp Interface my_interface.hpp my_interface.cpp my_interface.py pycffi_lib_build.py cw__my_interface.cpp cw__my_interface.h cw__my_interface.hpp Generated only for types that contain constants. Additional C Wrapper files are generated for data structures; their names are encoded as: dh__{list,set,map}_{encoded_type(s)}.cpp dh__{list,set,map}_{encoded_type(s)}.h dh__{list,set,map}_{encoded_type(s)}.hpp See the in the table below a few examples: Type C Wrapper list<i32> dh__list_int32_t.{cpp,h,hpp} set<string> dh__set_string.{cpp,h,hpp} map<i32, set<string>> dh__map_int32_t_set_string.{cpp,h,hpp} Add all generated C and C++ source files to your build target, and link it against the djinni-support-lib . Compile the Python extension module (CFFI) by executing pycffi_lib_build.py while providing all C Wrapper header files ( .h ) as arguments. The resulting shared library will enable Python to access your C++ library through the CFFI bridge. Known limitations of the generator \u00b6 External types defined in YAML are not yet supported. Use of non-nullable pointers is not yet supported.","title":"Use Generated Code"},{"location":"djinni-generator/generated-code-usage/#use-generated-code","text":"","title":"Use Generated Code"},{"location":"djinni-generator/generated-code-usage/#java-jni-c-project","text":"","title":"Java / JNI / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target","text":"The following headers / code will be generated for each defined type: Type C++ header C++ source Java JNI header JNI source Enum/Flags my_enum.hpp MyEnum.java NativeMyEnum.hpp NativeMyEnum.cpp Record my_record[_base].hpp my_record[_base].cpp (+) MyRecord[Base].java NativeMyRecord.hpp NativeMyRecord.cpp Interface my_interface.hpp my_interface.cpp (+) MyInterface.java NativeMyInterface.hpp NativeMyInterface.cpp (+) Generated only for types that contain constants. Add all generated source files to your build target, and link the C++ code against the djinni-support-lib .","title":"Includes &amp; Build target"},{"location":"djinni-generator/generated-code-usage/#our-jni-approach","text":"JNI stands for Java Native Interface , an extension of the Java language to allow interop with native (C/C++) code or libraries. For each type, built-in ( list , string , etc.) or user-defined, Djinni produces a translator class with a toJava and fromJava function to translate back and forth. Application code is responsible for the initial load of the JNI library. Add a static block somewhere in your code: class Main { static { System . loadLibrary ( \"YourLibraryName\" ); // The name of the library is specified in Android.mk / build.gradle / Makefile / CMakeLists.txt, // depending on your build system. } } If you package your native library in a jar, you can also use the NativeLibLoader to help unpack and load your lib(s). When a native library is called, JNI calls a special function called JNI_OnLoad . If your app doesn't use JNI except through Djinni, include djinni/jni/djinni_main.cpp . It defines default JNI_Onload and JNI_OnUnload functions for Djinni. If your app also includes a non-Djinni JNI interface, you'll need to define your own JNI_OnLoad and JNI_OnUnload functions.","title":"Our JNI approach"},{"location":"djinni-generator/generated-code-usage/#objective-c-c-project","text":"","title":"Objective-C / C++ Project"},{"location":"djinni-generator/generated-code-usage/#includes-build-target_1","text":"Generated files for Objective-C / C++ are as follows (assuming prefix is DB ): Type C++ header C++ source Objective-C files Objective-C++ files Enum/Flags my_enum.hpp DBMyEnum.h Record my_record[_base].hpp my_record[_base].cpp DBMyRecord[Base].h DBMyRecord[Base]+Private.h DBMyRecord[Base].mm DBMyRecord[Base]+Private.mm Interface my_interface.hpp my_interface.cpp DBMyInterface.h DBMyInterface+Private.h DBMyInterface+Private.mm Generated only for types that contain constants. Generated only for types with derived operations and/or constants. These have .mm extensions to allow non-trivial constants. Add all generated files to your build target, and link against the djinni-support-lib . Note that +Private files can only be used with ObjC++ source (other headers are pure ObjC) and are not required by Objective-C users of your interface.","title":"Includes &amp; Build Target"},{"location":"djinni-generator/generated-code-usage/#python-c-project-experimental","text":"Python support in Djinni is experimental, but ready to try out. It can generate code for bridging C++ with Python 3. For more information, you can check out the talk from CppCon 2015. Slides and video are available online.","title":"Python / C++ Project (Experimental)"},{"location":"djinni-generator/generated-code-usage/#includes-build-target_2","text":"When bridging to Python, Djinni generates 4 types of output: python Generated Python classes and proxies for interacting with C++ via CFFI . cffi Python code run at build time to create a Python extension out of the C++ code. cwrapper A C interface implemented in C++ to allowing Python to interact with C++ classes. cpp The same C++ classes generated for all other Djinni languages. Generated files for Python / C++ are as follows: Type C++ header C++ source Python files CFFI C Wrapper Enum/Flags my_enum.hpp my_enum.py dh__my_enum.cpp dh__my_enum.h dh__my_enum.hpp Record my_record[_base].hpp my_record[_base].cpp my_record[_base].py dh__my_record.cpp dh__my_record.h dh__my_record.hpp Interface my_interface.hpp my_interface.cpp my_interface.py pycffi_lib_build.py cw__my_interface.cpp cw__my_interface.h cw__my_interface.hpp Generated only for types that contain constants. Additional C Wrapper files are generated for data structures; their names are encoded as: dh__{list,set,map}_{encoded_type(s)}.cpp dh__{list,set,map}_{encoded_type(s)}.h dh__{list,set,map}_{encoded_type(s)}.hpp See the in the table below a few examples: Type C Wrapper list<i32> dh__list_int32_t.{cpp,h,hpp} set<string> dh__set_string.{cpp,h,hpp} map<i32, set<string>> dh__map_int32_t_set_string.{cpp,h,hpp} Add all generated C and C++ source files to your build target, and link it against the djinni-support-lib . Compile the Python extension module (CFFI) by executing pycffi_lib_build.py while providing all C Wrapper header files ( .h ) as arguments. The resulting shared library will enable Python to access your C++ library through the CFFI bridge.","title":"Includes &amp; Build Target"},{"location":"djinni-generator/generated-code-usage/#known-limitations-of-the-generator","text":"External types defined in YAML are not yet supported. Use of non-nullable pointers is not yet supported.","title":"Known limitations of the generator"},{"location":"djinni-generator/idl/","text":"Interface Definition Language (IDL) \u00b6 Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC and Python and can be called from C++. my_client_interface = interface +j +o +p { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once. Data Types \u00b6 The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, NSData in Objective-C, and an object supporting the buffer interface in Python. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, NSDate in Objective-C, and datetime.datetime in Python. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, NSArray in Objective-C, and List in Python. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, NSSet in Objective-C, and Set in Python. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, NSDictionary in Objective-C, and Dictionary in Python. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents. Types \u00b6 An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, ObjC NS_ENUM s, or Python IntEnum s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , ObjC NS_OPTIONS , or Python IntFlag s. Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java, or Python and vice versa. Enums \u00b6 my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , Java enums, and Python IntEnum s. Flags \u00b6 my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , Java EnumSet<> , and Python IntFlag . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++, ObjC, and Python the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() . Records \u00b6 my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself). Extensions \u00b6 To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), +o (ObjC), or +p (Python) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type. Derived methods \u00b6 another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java, Objective-C, and Python. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record. Interfaces \u00b6 # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC, and Python and can be called from C++. my_client_interface = interface +j +o +p { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java or Python and vice versa. Special Methods for C++ Only \u00b6 +c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor. Exception Handling \u00b6 When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java, an NSException in Objective-C or a RuntimeError in Python. The what() message will be translated as well. Constants \u00b6 Constants can be defined within interfaces and records. In Java, Python and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o +p { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, RecordWithConst.CONST_VALUE in Python, and RecordWithConstConstValue in Objective-C. Comments \u00b6 # This is a comment If comments are are placed on top or inside a type definition , they will be converted to Javadoc / Doxygen compatible comments in the generated Java/C++/Objective-C interfaces, or a Python docstring .","title":"Interface Definition Language (IDL)"},{"location":"djinni-generator/idl/#interface-definition-language-idl","text":"Djinni's input is an interface description file. Here's an example: # Multi-line comments can be added here. This comment will be propagated # to each generated definition. my_enum = enum { option1; option2; option3; } my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } another_record = record { key1: i32; key2: string; } deriving (eq, ord) # This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC and Python and can be called from C++. my_client_interface = interface +j +o +p { log_string(str: string): bool; } Djinni files can also include each other. Adding the line: @import \"relative/path/to/filename.djinni\" at the beginning of a file will simply include another file. Child file paths are relative to the location of the file that contains the @import. Two different djinni files cannot define the same type. @import behaves like #include with #pragma once in C++, or like ObjC's #import : if a file is included multiple times through different paths, then it will only be processed once.","title":"Interface Definition Language (IDL)"},{"location":"djinni-generator/idl/#data-types","text":"The available data types for a record, argument, or return value are: Boolean ( bool ) Primitives ( i8 , i16 , i32 , i64 , f32 , f64 ). Strings ( string ) Binary ( binary ). This is implemented as std::vector<uint8_t> in C++, byte[] in Java, NSData in Objective-C, and an object supporting the buffer interface in Python. Date ( date ). This is chrono::system_clock::time_point in C++, Date in Java, NSDate in Objective-C, and datetime.datetime in Python. List ( list<type> ). This is vector<T> in C++, ArrayList in Java, NSArray in Objective-C, and List in Python. Primitives in a list will be boxed in Java and Objective-C. Set ( set<type> ). This is unordered_set<T> in C++, HashSet in Java, NSSet in Objective-C, and Set in Python. Primitives in a set will be boxed in Java and Objective-C. Map ( map<typeA, typeB> ). This is unordered_map<K, V> in C++, HashMap in Java, NSDictionary in Objective-C, and Dictionary in Python. Primitives in a map will be boxed in Java and Objective-C. Enumerations / Flags Optionals ( optional<typeA> ). This is std::experimental::optional<T> in C++11, object / boxed primitive reference in Java (which can be null ), and object / NSNumber strong reference in Objective-C (which can be nil ). Other record types. This is generated with a by-value semantic, i.e. the copy method will deep-copy the contents.","title":"Data Types"},{"location":"djinni-generator/idl/#types","text":"An IDL file can contain 4 kinds of declarations: enums, flags, records, and interfaces. Enums become C++ enum classes, Java enums, ObjC NS_ENUM s, or Python IntEnum s. Flags become C++ enum classes with convenient bit-oriented operators, Java enums with EnumSet , ObjC NS_OPTIONS , or Python IntFlag s. Records are pure-data value objects. Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java, or Python and vice versa.","title":"Types"},{"location":"djinni-generator/idl/#enums","text":"my_enum = enum { option1; option2; option3; } Enums are translated to C++ enum class es with underlying type int , ObjC NS_ENUM s with underlying type NSInteger , Java enums, and Python IntEnum s.","title":"Enums"},{"location":"djinni-generator/idl/#flags","text":"my_flags = flags { flag1; flag2; flag3; no_flags = none; all_flags = all; } Flags are translated to C++ enum class es with underlying type unsigned and a generated set of overloaded bitwise operators for convenience, ObjC NS_OPTIONS with underlying type NSUInteger , Java EnumSet<> , and Python IntFlag . Contrary to the above enums, the enumerants of flags represent single bits instead of integral values. In the above example the elements marked with none and all are given special meaning. In C++, ObjC, and Python the no_flags option is generated with a value that has no bits set (i.e. 0 ), and all_flags is generated as a bitwise-or combination of all other values. In Java these special options are not generated as one can just use EnumSet.noneOf() and EnumSet.allOf() .","title":"Flags"},{"location":"djinni-generator/idl/#records","text":"my_record = record { id: i32; info: string; store: set<string>; hash: map<string, i32>; values: list<another_record>; # Comments can also be put here # Constants can be included const string_const: string = \"Constants can be put here\"; const min_value: another_record = { key1 = 0, key2 = \"\" }; } Records are data objects. In C++, records contain all their elements by value, including other records (so a record cannot contain itself).","title":"Records"},{"location":"djinni-generator/idl/#extensions","text":"To support extra fields and/or methods, a record can be \"extended\" in any language. To extend a record in a language, you can add a +c (C++), +j (Java), +o (ObjC), or +p (Python) flag after the record tag. The generated type will have a Base suffix, and you should create a derived type without the suffix that extends the record type. The derived type must be constructible in the same way as the Base type. Interfaces will always use the derived type.","title":"Extensions"},{"location":"djinni-generator/idl/#derived-methods","text":"another_record = record { key1: i32; key2: string; } deriving (eq, ord) For record types, Haskell-style \"deriving\" declarations are supported to generate some common methods. Djinni is capable of generating equality and order comparators, implemented as operator overloading in C++ and standard comparison functions in Java, Objective-C, and Python. Note All fields in the record are compared in the order they appear in the record declaration. If you need to add a field later, make sure the order is correct. Ordering comparison is not supported for collection types, optionals, and booleans. To compare records containing other records, the inner record must derive at least the same types of comparators as the outer record.","title":"Derived methods"},{"location":"djinni-generator/idl/#interfaces","text":"# This interface will be implemented in C++ and can be called from any language. my_cpp_interface = interface +c { method_returning_nothing(value: i32); method_returning_some_type(key: string): another_record; static get_version(): i32; # Interfaces can also have constants const version: i32 = 1; } # This interface will be implemented in Java, ObjC, and Python and can be called from C++. my_client_interface = interface +j +o +p { log_string(str: string): bool; } Interfaces are objects with defined methods to call (in C++, passed by shared_ptr ). Djinni produces code allowing an interface implemented in C++ to be transparently used from ObjC, Java or Python and vice versa.","title":"Interfaces"},{"location":"djinni-generator/idl/#special-methods-for-c-only","text":"+c interfaces (implementable only in C++) can have methods flagged with the special keywords const and static which have special effects in C++: special_methods = interface +c { const accessor_method(); static factory_method(); } const methods will be declared as const in C++, though this cannot be enforced on callers in other languages, which lack this feature. static methods will become a static method of the C++ class, which can be called from other languages without an object. This is often useful for factory methods to act as a cross-language constructor.","title":"Special Methods for C++ Only"},{"location":"djinni-generator/idl/#exception-handling","text":"When an interface implemented in C++ throws a std::exception , it will be translated to a java.lang.RuntimeException in Java, an NSException in Objective-C or a RuntimeError in Python. The what() message will be translated as well.","title":"Exception Handling"},{"location":"djinni-generator/idl/#constants","text":"Constants can be defined within interfaces and records. In Java, Python and C++ they are part of the generated class; and in Objective-C, constant names are globals with the name of the interface/record prefixed. Example: record_with_const = record +c +j +o +p { const const_value: i32 = 8; } will be RecordWithConst::CONST_VALUE in C++, RecordWithConst.CONST_VALUE in Java, RecordWithConst.CONST_VALUE in Python, and RecordWithConstConstValue in Objective-C.","title":"Constants"},{"location":"djinni-generator/idl/#comments","text":"# This is a comment If comments are are placed on top or inside a type definition , they will be converted to Javadoc / Doxygen compatible comments in the generated Java/C++/Objective-C interfaces, or a Python docstring .","title":"Comments"},{"location":"djinni-generator/setup/","text":"Generator Setup \u00b6 Installation \u00b6 Important The generator requires Java ! Linux, macOS \u00b6 Manually \u00b6 Install with asdf \u00b6 asdf plugin add djinni asdf install djinni latest Windows \u00b6 Conan \u00b6 The generator is available at conan-center for Windows, Linux & macOS. Add the generator as a build requirement in conanfile.txt : [build_requires] djinni-generator/0.3.1","title":"Generator Setup"},{"location":"djinni-generator/setup/#generator-setup","text":"","title":"Generator Setup"},{"location":"djinni-generator/setup/#installation","text":"Important The generator requires Java !","title":"Installation"},{"location":"djinni-generator/setup/#linux-macos","text":"","title":"Linux, macOS"},{"location":"djinni-generator/setup/#manually","text":"","title":"Manually"},{"location":"djinni-generator/setup/#install-with-asdf","text":"asdf plugin add djinni asdf install djinni latest","title":"Install with asdf"},{"location":"djinni-generator/setup/#windows","text":"","title":"Windows"},{"location":"djinni-generator/setup/#conan","text":"The generator is available at conan-center for Windows, Linux & macOS. Add the generator as a build requirement in conanfile.txt : [build_requires] djinni-generator/0.3.1","title":"Conan"},{"location":"djinni-intellij-plugin/","text":"About IntelliJ IDEA Plugin \u00b6 Adds basic navigation, code-completion and error highlighting support for .djinni IDL files. Get the plugin in the Jetbrains Marketplace:","title":"About IntelliJ IDEA Plugin"},{"location":"djinni-intellij-plugin/#about-intellij-idea-plugin","text":"Adds basic navigation, code-completion and error highlighting support for .djinni IDL files. Get the plugin in the Jetbrains Marketplace:","title":"About IntelliJ IDEA Plugin"},{"location":"djinni-intellij-plugin/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only of interest if you want to make changes to the code of the intellij plugin! Development Basics \u00b6 Build \u00b6 To build on your local machine, run the buildPlugin task ./gradlew buildPlugin Debug \u00b6 With the runIde task you can run the plugin in an isolated IDE and get logs about whats going on. Install \u00b6 To install the plugin you just built locally, go to Preferences > Plugins > Marketplace > \u2699 > Install plugin from disk... You can find the built plugin package under build/distributions/djinni-intellij-plugin-<version>.zip Adjusting grammar \u00b6 The grammar for .djinni files is defined in Backus\u2013Naur form in Djinni.bnf If you decide to make changes to this file, the following manual steps are required to apply them: Djinni.bnf : Right-Click > Generate Parser Code Right-Click > Generate JFlex Lexer , in the file dialog click Save and Replace _DjinniLexer.flex : Right-Click > Run JFlex Generator Release process \u00b6 To release a new plugin version, the following steps must be followed: Create a new release-tag on github. Set a meaningful version number and describe what has changed in the new version. Wait. Github will automatically build the plugin, publish it to the jetbrains marketplace & upload the plugin-artifact to the release. The update will be verified by Jetbrains within a few days. Then it will be distributed to the users.","title":"Developer Guide"},{"location":"djinni-intellij-plugin/developer-guide/#developer-guide","text":"Info This chapter is only of interest if you want to make changes to the code of the intellij plugin!","title":"Developer Guide"},{"location":"djinni-intellij-plugin/developer-guide/#development-basics","text":"","title":"Development Basics"},{"location":"djinni-intellij-plugin/developer-guide/#build","text":"To build on your local machine, run the buildPlugin task ./gradlew buildPlugin","title":"Build"},{"location":"djinni-intellij-plugin/developer-guide/#debug","text":"With the runIde task you can run the plugin in an isolated IDE and get logs about whats going on.","title":"Debug"},{"location":"djinni-intellij-plugin/developer-guide/#install","text":"To install the plugin you just built locally, go to Preferences > Plugins > Marketplace > \u2699 > Install plugin from disk... You can find the built plugin package under build/distributions/djinni-intellij-plugin-<version>.zip","title":"Install"},{"location":"djinni-intellij-plugin/developer-guide/#adjusting-grammar","text":"The grammar for .djinni files is defined in Backus\u2013Naur form in Djinni.bnf If you decide to make changes to this file, the following manual steps are required to apply them: Djinni.bnf : Right-Click > Generate Parser Code Right-Click > Generate JFlex Lexer , in the file dialog click Save and Replace _DjinniLexer.flex : Right-Click > Run JFlex Generator","title":"Adjusting grammar"},{"location":"djinni-intellij-plugin/developer-guide/#release-process","text":"To release a new plugin version, the following steps must be followed: Create a new release-tag on github. Set a meaningful version number and describe what has changed in the new version. Wait. Github will automatically build the plugin, publish it to the jetbrains marketplace & upload the plugin-artifact to the release. The update will be verified by Jetbrains within a few days. Then it will be distributed to the users.","title":"Release process"},{"location":"djinni-support-lib/install/","text":"Installing the Support-Lib \u00b6 conan \u00b6 TODO hunter \u00b6 TODO","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#installing-the-support-lib","text":"","title":"Installing the Support-Lib"},{"location":"djinni-support-lib/install/#conan","text":"TODO","title":"conan"},{"location":"djinni-support-lib/install/#hunter","text":"TODO","title":"hunter"},{"location":"vscode-djinni/","text":"About VS Code Extension \u00b6 Adds really basic syntax highlighting for djinni interface files. Get the extension in the Visual Studio Marketplace","title":"About VS Code Extension"},{"location":"vscode-djinni/#about-vs-code-extension","text":"Adds really basic syntax highlighting for djinni interface files. Get the extension in the Visual Studio Marketplace","title":"About VS Code Extension"},{"location":"vscode-djinni/developer-guide/","text":"Developer Guide \u00b6 Info This chapter is only of interest if you want to make changes to the code of the vscode extension! Development Basics \u00b6 Build dependencies \u00b6 node npm Building \u00b6 npm install # installs all required dependencies npm run package # builds the .vsix package Github Release Process \u00b6 To release a new extension version, the following steps must be followed: Create a new release-tag. Set a meaningful version number and describe what has changed in the new version. The version must be parseable by semver ! If you are not sure about that, you can check it: npm install -g semver # install semver semver <versiontag> # check if the version can be parsed Wait. Github will automatically build the extension, publish it to the Visual Studio Marketplace & upload the packaged extension to the release. That's it!","title":"Developer Guide"},{"location":"vscode-djinni/developer-guide/#developer-guide","text":"Info This chapter is only of interest if you want to make changes to the code of the vscode extension!","title":"Developer Guide"},{"location":"vscode-djinni/developer-guide/#development-basics","text":"","title":"Development Basics"},{"location":"vscode-djinni/developer-guide/#build-dependencies","text":"node npm","title":"Build dependencies"},{"location":"vscode-djinni/developer-guide/#building","text":"npm install # installs all required dependencies npm run package # builds the .vsix package","title":"Building"},{"location":"vscode-djinni/developer-guide/#github-release-process","text":"To release a new extension version, the following steps must be followed: Create a new release-tag. Set a meaningful version number and describe what has changed in the new version. The version must be parseable by semver ! If you are not sure about that, you can check it: npm install -g semver # install semver semver <versiontag> # check if the version can be parsed Wait. Github will automatically build the extension, publish it to the Visual Studio Marketplace & upload the packaged extension to the release. That's it!","title":"Github Release Process"}]}