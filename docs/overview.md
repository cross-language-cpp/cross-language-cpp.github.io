# Overview

## What is djinni?

Djinni is a tool for generating cross-language type declarations and interface bindings. It's designed to connect C++ with either Java or Objective-C.

Djinni can be used to interface cross-platform C++ library code with platform-specific Java and Objective-C on Android and iOS. Dropbox announced Djinni at CppCon 2014.

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/ZcBtF-JWJhM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

!!! tip "Djinni ❤️ Community!"

    Dropbox ended maintenance of Djinni in March 2020. This fork wants to give Djinni a second life by transforming it to a community-driven project.

    We are currently in the early stage of migration to the all new [cross-language-cpp](https://github.com/cross-language-cpp) organization. Everybody interested in helping us to form this new place is more than welcome!

## Main Features

- Generates parallel C++, Java and Objective-C type definitions from a single interface description file.
- Supports the intersection of the three core languages' primitive types, and user-defined enums, records, and interfaces.
- Generates interface code allowing bidirectional calls between C++ and Java (with JNI) or Objective-C (with Objective-C++).
- Can autogenerate comparator functions (equality, ordering) on data types.

## Components of Djinni

Djinni consists of 2 important components:

1. **Generator**: Takes a Djinni-IDL file as input and generates the gluecode.
2. **Support lib**: Library that is required for the gluecode to work.


## How the magic works

To call from one programming language to another, usually a lot of gluecode is required.
Djinni automatically generates this gluecode from in interface file.

All you need to do is implement the interfaces generated by djinni in one language and use it from the other language. Djinni takes care of the heavy lifting: Converting data-types, managing pointers and freeing memory.


### :arrow_right: Call C++ Code from Java or Objective-C

This Djinni Interface defines a class that is implemented in C++ and can be called from Java or Objective-C:
```
HelloWorld = interface +c {
    static init(): HelloWorld;
    fromCpp(): string
}
```



=== "Implemented in C++"

    ``` cpp
    #include "djinni/generated/HelloWorld.hpp"

    class HelloWorldImpl : public HelloWorld {
    public:
        static std::shared_ptr<HelloWorld> create() {
            return std::make_shared<HelloWorldImpl>();
        }
        std::string fromCpp() {
            return "Hello From C++!";
        }
    }
    ```

=== "Called from Java"

    ``` java
    HelloWorld helloWorld = HelloWorld.create();
    System.out.println(helloWorld.fromCpp());
    // Hello from C++!
    ```

=== "or Objective-C"

    ``` objc
    HelloWorld *helloWorld = [HelloWorld create];
    NSLog([helloWorld fromCpp]);
    // Hello from C++!
    ```

### :arrow_left: Call Java/Objective-C Code from C++

This Djinni interface can be implemented in either Java or Objective-C, and can be called from C++:

```
HelloWorld = interface +j +o {
    fromLanguage(): string;
}
```


=== "Implemented in Java"

    ``` java
    public class HelloWorldJava extends HelloWorld {
        @Override
        String fromLanguage() {
            return "from Java";
        }
    } 
    ```

=== "or Objective-C"

    ``` objc
    @interface HelloWorldObjC : NSObject <HelloWorld>
    - (NSString)fromLanguage; 
    @end

    @implementation HelloWorldObjC
    - (NSString)fromLanguage {
        return "from Objective-C";
    }
    @end
    ```

=== "Called from C++"

    ``` cpp
    std::cout << helloWorldInstance->fromLanguage() << std::endl;
    ```


